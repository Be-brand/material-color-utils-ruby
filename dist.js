var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("utils/math_utils", [], function (exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    // This file is automatically generated. Do not modify it.
    /**
     * Utility methods for mathematical operations.
     */
    /**
     * The signum function.
     *
     * @return 1 if num > 0, -1 if num < 0, and 0 if num = 0
     */
    function signum(num) {
        if (num < 0) {
            return -1;
        }
        else if (num === 0) {
            return 0;
        }
        else {
            return 1;
        }
    }
    exports_1("signum", signum);
    /**
     * The linear interpolation function.
     *
     * @return start if amount = 0 and stop if amount = 1
     */
    function lerp(start, stop, amount) {
        return (1.0 - amount) * start + amount * stop;
    }
    exports_1("lerp", lerp);
    /**
     * Clamps an integer between two integers.
     *
     * @return input when min <= input <= max, and either min or max
     * otherwise.
     */
    function clampInt(min, max, input) {
        if (input < min) {
            return min;
        }
        else if (input > max) {
            return max;
        }
        return input;
    }
    exports_1("clampInt", clampInt);
    /**
     * Clamps an integer between two floating-point numbers.
     *
     * @return input when min <= input <= max, and either min or max
     * otherwise.
     */
    function clampDouble(min, max, input) {
        if (input < min) {
            return min;
        }
        else if (input > max) {
            return max;
        }
        return input;
    }
    exports_1("clampDouble", clampDouble);
    /**
     * Sanitizes a degree measure as an integer.
     *
     * @return a degree measure between 0 (inclusive) and 360
     * (exclusive).
     */
    function sanitizeDegreesInt(degrees) {
        degrees = degrees % 360;
        if (degrees < 0) {
            degrees = degrees + 360;
        }
        return degrees;
    }
    exports_1("sanitizeDegreesInt", sanitizeDegreesInt);
    /**
     * Sanitizes a degree measure as a floating-point number.
     *
     * @return a degree measure between 0.0 (inclusive) and 360.0
     * (exclusive).
     */
    function sanitizeDegreesDouble(degrees) {
        degrees = degrees % 360.0;
        if (degrees < 0) {
            degrees = degrees + 360.0;
        }
        return degrees;
    }
    exports_1("sanitizeDegreesDouble", sanitizeDegreesDouble);
    /**
     * Sign of direction change needed to travel from one angle to
     * another.
     *
     * For angles that are 180 degrees apart from each other, both
     * directions have the same travel distance, so either direction is
     * shortest. The value 1.0 is returned in this case.
     *
     * @param from The angle travel starts from, in degrees.
     * @param to The angle travel ends at, in degrees.
     * @return -1 if decreasing from leads to the shortest travel
     * distance, 1 if increasing from leads to the shortest travel
     * distance.
     */
    function rotationDirection(from, to) {
        const increasingDifference = sanitizeDegreesDouble(to - from);
        return increasingDifference <= 180.0 ? 1.0 : -1.0;
    }
    exports_1("rotationDirection", rotationDirection);
    /**
     * Distance of two points on a circle, represented using degrees.
     */
    function differenceDegrees(a, b) {
        return 180.0 - Math.abs(Math.abs(a - b) - 180.0);
    }
    exports_1("differenceDegrees", differenceDegrees);
    /**
     * Multiplies a 1x3 row vector with a 3x3 matrix.
     */
    function matrixMultiply(row, matrix) {
        const a = row[0] * matrix[0][0] + row[1] * matrix[0][1] + row[2] * matrix[0][2];
        const b = row[0] * matrix[1][0] + row[1] * matrix[1][1] + row[2] * matrix[1][2];
        const c = row[0] * matrix[2][0] + row[1] * matrix[2][1] + row[2] * matrix[2][2];
        return [a, b, c];
    }
    exports_1("matrixMultiply", matrixMultiply);
    return {
        setters: [],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("utils/color_utils", ["utils/math_utils"], function (exports_2, context_2) {
    "use strict";
    var mathUtils, SRGB_TO_XYZ, XYZ_TO_SRGB, WHITE_POINT_D65;
    var __moduleName = context_2 && context_2.id;
    /**
     * Converts a color from RGB components to ARGB format.
     */
    function argbFromRgb(red, green, blue) {
        return (255 << 24 | (red & 255) << 16 | (green & 255) << 8 | blue & 255) >>>
            0;
    }
    exports_2("argbFromRgb", argbFromRgb);
    /**
     * Converts a color from linear RGB components to ARGB format.
     */
    function argbFromLinrgb(linrgb) {
        const r = delinearized(linrgb[0]);
        const g = delinearized(linrgb[1]);
        const b = delinearized(linrgb[2]);
        return argbFromRgb(r, g, b);
    }
    exports_2("argbFromLinrgb", argbFromLinrgb);
    /**
     * Returns the alpha component of a color in ARGB format.
     */
    function alphaFromArgb(argb) {
        return argb >> 24 & 255;
    }
    exports_2("alphaFromArgb", alphaFromArgb);
    /**
     * Returns the red component of a color in ARGB format.
     */
    function redFromArgb(argb) {
        return argb >> 16 & 255;
    }
    exports_2("redFromArgb", redFromArgb);
    /**
     * Returns the green component of a color in ARGB format.
     */
    function greenFromArgb(argb) {
        return argb >> 8 & 255;
    }
    exports_2("greenFromArgb", greenFromArgb);
    /**
     * Returns the blue component of a color in ARGB format.
     */
    function blueFromArgb(argb) {
        return argb & 255;
    }
    exports_2("blueFromArgb", blueFromArgb);
    /**
     * Returns whether a color in ARGB format is opaque.
     */
    function isOpaque(argb) {
        return alphaFromArgb(argb) >= 255;
    }
    exports_2("isOpaque", isOpaque);
    /**
     * Converts a color from ARGB to XYZ.
     */
    function argbFromXyz(x, y, z) {
        const matrix = XYZ_TO_SRGB;
        const linearR = matrix[0][0] * x + matrix[0][1] * y + matrix[0][2] * z;
        const linearG = matrix[1][0] * x + matrix[1][1] * y + matrix[1][2] * z;
        const linearB = matrix[2][0] * x + matrix[2][1] * y + matrix[2][2] * z;
        const r = delinearized(linearR);
        const g = delinearized(linearG);
        const b = delinearized(linearB);
        return argbFromRgb(r, g, b);
    }
    exports_2("argbFromXyz", argbFromXyz);
    /**
     * Converts a color from XYZ to ARGB.
     */
    function xyzFromArgb(argb) {
        const r = linearized(redFromArgb(argb));
        const g = linearized(greenFromArgb(argb));
        const b = linearized(blueFromArgb(argb));
        return mathUtils.matrixMultiply([r, g, b], SRGB_TO_XYZ);
    }
    exports_2("xyzFromArgb", xyzFromArgb);
    /**
     * Converts a color represented in Lab color space into an ARGB
     * integer.
     */
    function argbFromLab(l, a, b) {
        const whitePoint = WHITE_POINT_D65;
        const fy = (l + 16.0) / 116.0;
        const fx = a / 500.0 + fy;
        const fz = fy - b / 200.0;
        const xNormalized = labInvf(fx);
        const yNormalized = labInvf(fy);
        const zNormalized = labInvf(fz);
        const x = xNormalized * whitePoint[0];
        const y = yNormalized * whitePoint[1];
        const z = zNormalized * whitePoint[2];
        return argbFromXyz(x, y, z);
    }
    exports_2("argbFromLab", argbFromLab);
    /**
     * Converts a color from ARGB representation to L*a*b*
     * representation.
     *
     * @param argb the ARGB representation of a color
     * @return a Lab object representing the color
     */
    function labFromArgb(argb) {
        const linearR = linearized(redFromArgb(argb));
        const linearG = linearized(greenFromArgb(argb));
        const linearB = linearized(blueFromArgb(argb));
        const matrix = SRGB_TO_XYZ;
        const x = matrix[0][0] * linearR + matrix[0][1] * linearG + matrix[0][2] * linearB;
        const y = matrix[1][0] * linearR + matrix[1][1] * linearG + matrix[1][2] * linearB;
        const z = matrix[2][0] * linearR + matrix[2][1] * linearG + matrix[2][2] * linearB;
        const whitePoint = WHITE_POINT_D65;
        const xNormalized = x / whitePoint[0];
        const yNormalized = y / whitePoint[1];
        const zNormalized = z / whitePoint[2];
        const fx = labF(xNormalized);
        const fy = labF(yNormalized);
        const fz = labF(zNormalized);
        const l = 116.0 * fy - 16;
        const a = 500.0 * (fx - fy);
        const b = 200.0 * (fy - fz);
        return [l, a, b];
    }
    exports_2("labFromArgb", labFromArgb);
    /**
     * Converts an L* value to an ARGB representation.
     *
     * @param lstar L* in L*a*b*
     * @return ARGB representation of grayscale color with lightness
     * matching L*
     */
    function argbFromLstar(lstar) {
        const y = yFromLstar(lstar);
        const component = delinearized(y);
        return argbFromRgb(component, component, component);
    }
    exports_2("argbFromLstar", argbFromLstar);
    /**
     * Computes the L* value of a color in ARGB representation.
     *
     * @param argb ARGB representation of a color
     * @return L*, from L*a*b*, coordinate of the color
     */
    function lstarFromArgb(argb) {
        const y = xyzFromArgb(argb)[1];
        return 116.0 * labF(y / 100.0) - 16.0;
    }
    exports_2("lstarFromArgb", lstarFromArgb);
    /**
     * Converts an L* value to a Y value.
     *
     * L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
     *
     * L* measures perceptual luminance, a linear scale. Y in XYZ
     * measures relative luminance, a logarithmic scale.
     *
     * @param lstar L* in L*a*b*
     * @return Y in XYZ
     */
    function yFromLstar(lstar) {
        return 100.0 * labInvf((lstar + 16.0) / 116.0);
    }
    exports_2("yFromLstar", yFromLstar);
    /**
     * Linearizes an RGB component.
     *
     * @param rgbComponent 0 <= rgb_component <= 255, represents R/G/B
     * channel
     * @return 0.0 <= output <= 100.0, color channel converted to
     * linear RGB space
     */
    function linearized(rgbComponent) {
        const normalized = rgbComponent / 255.0;
        if (normalized <= 0.040449936) {
            return normalized / 12.92 * 100.0;
        }
        else {
            return Math.pow((normalized + 0.055) / 1.055, 2.4) * 100.0;
        }
    }
    exports_2("linearized", linearized);
    /**
     * Delinearizes an RGB component.
     *
     * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
     * linear R/G/B channel
     * @return 0 <= output <= 255, color channel converted to regular
     * RGB space
     */
    function delinearized(rgbComponent) {
        const normalized = rgbComponent / 100.0;
        let delinearized = 0.0;
        if (normalized <= 0.0031308) {
            delinearized = normalized * 12.92;
        }
        else {
            delinearized = 1.055 * Math.pow(normalized, 1.0 / 2.4) - 0.055;
        }
        return mathUtils.clampInt(0, 255, Math.round(delinearized * 255.0));
    }
    exports_2("delinearized", delinearized);
    /**
     * Returns the standard white point; white on a sunny day.
     *
     * @return The white point
     */
    function whitePointD65() {
        return WHITE_POINT_D65;
    }
    exports_2("whitePointD65", whitePointD65);
    function labF(t) {
        const e = 216.0 / 24389.0;
        const kappa = 24389.0 / 27.0;
        if (t > e) {
            return Math.pow(t, 1.0 / 3.0);
        }
        else {
            return (kappa * t + 16) / 116;
        }
    }
    function labInvf(ft) {
        const e = 216.0 / 24389.0;
        const kappa = 24389.0 / 27.0;
        const ft3 = ft * ft * ft;
        if (ft3 > e) {
            return ft3;
        }
        else {
            return (116 * ft - 16) / kappa;
        }
    }
    return {
        setters: [
            function (mathUtils_1) {
                mathUtils = mathUtils_1;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * Color science utilities.
             *
             * Utility methods for color science constants and color space
             * conversions that aren't HCT or CAM16.
             */
            SRGB_TO_XYZ = [
                [0.41233895, 0.35762064, 0.18051042],
                [0.2126, 0.7152, 0.0722],
                [0.01932141, 0.11916382, 0.95034478],
            ];
            XYZ_TO_SRGB = [
                [
                    3.2413774792388685,
                    -1.5376652402851851,
                    -0.49885366846268053,
                ],
                [
                    -0.9691452513005321,
                    1.8758853451067872,
                    0.04156585616912061,
                ],
                [
                    0.05562093689691305,
                    -0.20395524564742123,
                    1.0571799111220335,
                ],
            ];
            WHITE_POINT_D65 = [95.047, 100.0, 108.883];
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("hct/viewing_conditions", ["utils/color_utils", "utils/math_utils"], function (exports_3, context_3) {
    "use strict";
    var utils, math, ViewingConditions;
    var __moduleName = context_3 && context_3.id;
    return {
        setters: [
            function (utils_1) {
                utils = utils_1;
            },
            function (math_1) {
                math = math_1;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * In traditional color spaces, a color can be identified solely by the
             * observer's measurement of the color. Color appearance models such as CAM16
             * also use information about the environment where the color was
             * observed, known as the viewing conditions.
             *
             * For example, white under the traditional assumption of a midday sun white
             * point is accurately measured as a slightly chromatic blue by CAM16. (roughly,
             * hue 203, chroma 3, lightness 100)
             *
             * This class caches intermediate values of the CAM16 conversion process that
             * depend only on viewing conditions, enabling speed ups.
             */
            ViewingConditions = class ViewingConditions {
                /**
                 * Parameters are intermediate values of the CAM16 conversion process. Their
                 * names are shorthand for technical color science terminology, this class
                 * would not benefit from documenting them individually. A brief overview
                 * is available in the CAM16 specification, and a complete overview requires
                 * a color science textbook, such as Fairchild's Color Appearance Models.
                 */
                constructor(n, aw, nbb, ncb, c, nc, rgbD, fl, fLRoot, z) {
                    this.n = n;
                    this.aw = aw;
                    this.nbb = nbb;
                    this.ncb = ncb;
                    this.c = c;
                    this.nc = nc;
                    this.rgbD = rgbD;
                    this.fl = fl;
                    this.fLRoot = fLRoot;
                    this.z = z;
                }
                /**
                 * Create ViewingConditions from a simple, physically relevant, set of
                 * parameters.
                 *
                 * @param whitePoint White point, measured in the XYZ color space.
                 *     default = D65, or sunny day afternoon
                 * @param adaptingLuminance The luminance of the adapting field. Informally,
                 *     how bright it is in the room where the color is viewed. Can be
                 *     calculated from lux by multiplying lux by 0.0586. default = 11.72,
                 *     or 200 lux.
                 * @param backgroundLstar The lightness of the area surrounding the color.
                 *     measured by L* in L*a*b*. default = 50.0
                 * @param surround A general description of the lighting surrounding the
                 *     color. 0 is pitch dark, like watching a movie in a theater. 1.0 is a
                 *     dimly light room, like watching TV at home at night. 2.0 means there
                 *     is no difference between the lighting on the color and around it.
                 *     default = 2.0
                 * @param discountingIlluminant Whether the eye accounts for the tint of the
                 *     ambient lighting, such as knowing an apple is still red in green light.
                 *     default = false, the eye does not perform this process on
                 *       self-luminous objects like displays.
                 */
                static make(whitePoint = utils.whitePointD65(), adaptingLuminance = (200.0 / Math.PI) * utils.yFromLstar(50.0) / 100.0, backgroundLstar = 50.0, surround = 2.0, discountingIlluminant = false) {
                    const xyz = whitePoint;
                    const rW = xyz[0] * 0.401288 + xyz[1] * 0.650173 + xyz[2] * -0.051461;
                    const gW = xyz[0] * -0.250268 + xyz[1] * 1.204414 + xyz[2] * 0.045854;
                    const bW = xyz[0] * -0.002079 + xyz[1] * 0.048952 + xyz[2] * 0.953127;
                    const f = 0.8 + surround / 10.0;
                    const c = f >= 0.9 ? math.lerp(0.59, 0.69, (f - 0.9) * 10.0) :
                        math.lerp(0.525, 0.59, (f - 0.8) * 10.0);
                    let d = discountingIlluminant ?
                        1.0 :
                        f * (1.0 - (1.0 / 3.6) * Math.exp((-adaptingLuminance - 42.0) / 92.0));
                    d = d > 1.0 ? 1.0 : d < 0.0 ? 0.0 : d;
                    const nc = f;
                    const rgbD = [
                        d * (100.0 / rW) + 1.0 - d,
                        d * (100.0 / gW) + 1.0 - d,
                        d * (100.0 / bW) + 1.0 - d,
                    ];
                    const k = 1.0 / (5.0 * adaptingLuminance + 1.0);
                    const k4 = k * k * k * k;
                    const k4F = 1.0 - k4;
                    const fl = k4 * adaptingLuminance +
                        0.1 * k4F * k4F * Math.cbrt(5.0 * adaptingLuminance);
                    const n = utils.yFromLstar(backgroundLstar) / whitePoint[1];
                    const z = 1.48 + Math.sqrt(n);
                    const nbb = 0.725 / Math.pow(n, 0.2);
                    const ncb = nbb;
                    const rgbAFactors = [
                        Math.pow((fl * rgbD[0] * rW) / 100.0, 0.42),
                        Math.pow((fl * rgbD[1] * gW) / 100.0, 0.42),
                        Math.pow((fl * rgbD[2] * bW) / 100.0, 0.42),
                    ];
                    const rgbA = [
                        (400.0 * rgbAFactors[0]) / (rgbAFactors[0] + 27.13),
                        (400.0 * rgbAFactors[1]) / (rgbAFactors[1] + 27.13),
                        (400.0 * rgbAFactors[2]) / (rgbAFactors[2] + 27.13),
                    ];
                    const aw = (2.0 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]) * nbb;
                    return new ViewingConditions(n, aw, nbb, ncb, c, nc, rgbD, fl, Math.pow(fl, 0.25), z);
                }
            };
            exports_3("ViewingConditions", ViewingConditions);
            /** sRGB-like viewing conditions.  */
            ViewingConditions.DEFAULT = ViewingConditions.make();
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("hct/cam16", ["utils/color_utils", "utils/math_utils", "hct/viewing_conditions"], function (exports_4, context_4) {
    "use strict";
    var utils, math, viewing_conditions_1, Cam16;
    var __moduleName = context_4 && context_4.id;
    return {
        setters: [
            function (utils_2) {
                utils = utils_2;
            },
            function (math_2) {
                math = math_2;
            },
            function (viewing_conditions_1_1) {
                viewing_conditions_1 = viewing_conditions_1_1;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * CAM16, a color appearance model. Colors are not just defined by their hex
             * code, but rather, a hex code and viewing conditions.
             *
             * CAM16 instances also have coordinates in the CAM16-UCS space, called J*, a*,
             * b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
             * specification, and should be used when measuring distances between colors.
             *
             * In traditional color spaces, a color can be identified solely by the
             * observer's measurement of the color. Color appearance models such as CAM16
             * also use information about the environment where the color was
             * observed, known as the viewing conditions.
             *
             * For example, white under the traditional assumption of a midday sun white
             * point is accurately measured as a slightly chromatic blue by CAM16. (roughly,
             * hue 203, chroma 3, lightness 100)
             */
            Cam16 = class Cam16 {
                /**
                 * All of the CAM16 dimensions can be calculated from 3 of the dimensions, in
                 * the following combinations:
                 *      -  {j or q} and {c, m, or s} and hue
                 *      - jstar, astar, bstar
                 * Prefer using a static method that constructs from 3 of those dimensions.
                 * This constructor is intended for those methods to use to return all
                 * possible dimensions.
                 *
                 * @param hue
                 * @param chroma informally, colorfulness / color intensity. like saturation
                 *     in HSL, except perceptually accurate.
                 * @param j lightness
                 * @param q brightness; ratio of lightness to white point's lightness
                 * @param m colorfulness
                 * @param s saturation; ratio of chroma to white point's chroma
                 * @param jstar CAM16-UCS J coordinate
                 * @param astar CAM16-UCS a coordinate
                 * @param bstar CAM16-UCS b coordinate
                 */
                constructor(hue, chroma, j, q, m, s, jstar, astar, bstar) {
                    this.hue = hue;
                    this.chroma = chroma;
                    this.j = j;
                    this.q = q;
                    this.m = m;
                    this.s = s;
                    this.jstar = jstar;
                    this.astar = astar;
                    this.bstar = bstar;
                }
                /**
                 * CAM16 instances also have coordinates in the CAM16-UCS space, called J*,
                 * a*, b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
                 * specification, and is used to measure distances between colors.
                 */
                distance(other) {
                    const dJ = this.jstar - other.jstar;
                    const dA = this.astar - other.astar;
                    const dB = this.bstar - other.bstar;
                    const dEPrime = Math.sqrt(dJ * dJ + dA * dA + dB * dB);
                    const dE = 1.41 * Math.pow(dEPrime, 0.63);
                    return dE;
                }
                /**
                 * @param argb ARGB representation of a color.
                 * @return CAM16 color, assuming the color was viewed in default viewing
                 *     conditions.
                 */
                static fromInt(argb) {
                    return Cam16.fromIntInViewingConditions(argb, viewing_conditions_1.ViewingConditions.DEFAULT);
                }
                /**
                 * @param argb ARGB representation of a color.
                 * @param viewingConditions Information about the environment where the color
                 *     was observed.
                 * @return CAM16 color.
                 */
                static fromIntInViewingConditions(argb, viewingConditions) {
                    const red = (argb & 0x00ff0000) >> 16;
                    const green = (argb & 0x0000ff00) >> 8;
                    const blue = (argb & 0x000000ff);
                    const redL = utils.linearized(red);
                    const greenL = utils.linearized(green);
                    const blueL = utils.linearized(blue);
                    const x = 0.41233895 * redL + 0.35762064 * greenL + 0.18051042 * blueL;
                    const y = 0.2126 * redL + 0.7152 * greenL + 0.0722 * blueL;
                    const z = 0.01932141 * redL + 0.11916382 * greenL + 0.95034478 * blueL;
                    const rC = 0.401288 * x + 0.650173 * y - 0.051461 * z;
                    const gC = -0.250268 * x + 1.204414 * y + 0.045854 * z;
                    const bC = -0.002079 * x + 0.048952 * y + 0.953127 * z;
                    const rD = viewingConditions.rgbD[0] * rC;
                    const gD = viewingConditions.rgbD[1] * gC;
                    const bD = viewingConditions.rgbD[2] * bC;
                    const rAF = Math.pow((viewingConditions.fl * Math.abs(rD)) / 100.0, 0.42);
                    const gAF = Math.pow((viewingConditions.fl * Math.abs(gD)) / 100.0, 0.42);
                    const bAF = Math.pow((viewingConditions.fl * Math.abs(bD)) / 100.0, 0.42);
                    const rA = (math.signum(rD) * 400.0 * rAF) / (rAF + 27.13);
                    const gA = (math.signum(gD) * 400.0 * gAF) / (gAF + 27.13);
                    const bA = (math.signum(bD) * 400.0 * bAF) / (bAF + 27.13);
                    const a = (11.0 * rA + -12.0 * gA + bA) / 11.0;
                    const b = (rA + gA - 2.0 * bA) / 9.0;
                    const u = (20.0 * rA + 20.0 * gA + 21.0 * bA) / 20.0;
                    const p2 = (40.0 * rA + 20.0 * gA + bA) / 20.0;
                    const atan2 = Math.atan2(b, a);
                    const atanDegrees = (atan2 * 180.0) / Math.PI;
                    const hue = atanDegrees < 0 ? atanDegrees + 360.0 :
                        atanDegrees >= 360 ? atanDegrees - 360.0 :
                            atanDegrees;
                    const hueRadians = (hue * Math.PI) / 180.0;
                    const ac = p2 * viewingConditions.nbb;
                    const j = 100.0 *
                        Math.pow(ac / viewingConditions.aw, viewingConditions.c * viewingConditions.z);
                    const q = (4.0 / viewingConditions.c) * Math.sqrt(j / 100.0) *
                        (viewingConditions.aw + 4.0) * viewingConditions.fLRoot;
                    const huePrime = hue < 20.14 ? hue + 360 : hue;
                    const eHue = 0.25 * (Math.cos((huePrime * Math.PI) / 180.0 + 2.0) + 3.8);
                    const p1 = (50000.0 / 13.0) * eHue * viewingConditions.nc * viewingConditions.ncb;
                    const t = (p1 * Math.sqrt(a * a + b * b)) / (u + 0.305);
                    const alpha = Math.pow(t, 0.9) *
                        Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73);
                    const c = alpha * Math.sqrt(j / 100.0);
                    const m = c * viewingConditions.fLRoot;
                    const s = 50.0 *
                        Math.sqrt((alpha * viewingConditions.c) / (viewingConditions.aw + 4.0));
                    const jstar = ((1.0 + 100.0 * 0.007) * j) / (1.0 + 0.007 * j);
                    const mstar = (1.0 / 0.0228) * Math.log(1.0 + 0.0228 * m);
                    const astar = mstar * Math.cos(hueRadians);
                    const bstar = mstar * Math.sin(hueRadians);
                    return new Cam16(hue, c, j, q, m, s, jstar, astar, bstar);
                }
                /**
                 * @param j CAM16 lightness
                 * @param c CAM16 chroma
                 * @param h CAM16 hue
                 */
                static fromJch(j, c, h) {
                    return Cam16.fromJchInViewingConditions(j, c, h, viewing_conditions_1.ViewingConditions.DEFAULT);
                }
                /**
                 * @param j CAM16 lightness
                 * @param c CAM16 chroma
                 * @param h CAM16 hue
                 * @param viewingConditions Information about the environment where the color
                 *     was observed.
                 */
                static fromJchInViewingConditions(j, c, h, viewingConditions) {
                    const q = (4.0 / viewingConditions.c) * Math.sqrt(j / 100.0) *
                        (viewingConditions.aw + 4.0) * viewingConditions.fLRoot;
                    const m = c * viewingConditions.fLRoot;
                    const alpha = c / Math.sqrt(j / 100.0);
                    const s = 50.0 *
                        Math.sqrt((alpha * viewingConditions.c) / (viewingConditions.aw + 4.0));
                    const hueRadians = (h * Math.PI) / 180.0;
                    const jstar = ((1.0 + 100.0 * 0.007) * j) / (1.0 + 0.007 * j);
                    const mstar = (1.0 / 0.0228) * Math.log(1.0 + 0.0228 * m);
                    const astar = mstar * Math.cos(hueRadians);
                    const bstar = mstar * Math.sin(hueRadians);
                    return new Cam16(h, c, j, q, m, s, jstar, astar, bstar);
                }
                /**
                 * @param jstar CAM16-UCS lightness.
                 * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
                 *     coordinate on the Y axis.
                 * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
                 *     coordinate on the X axis.
                 */
                static fromUcs(jstar, astar, bstar) {
                    return Cam16.fromUcsInViewingConditions(jstar, astar, bstar, viewing_conditions_1.ViewingConditions.DEFAULT);
                }
                /**
                 * @param jstar CAM16-UCS lightness.
                 * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
                 *     coordinate on the Y axis.
                 * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
                 *     coordinate on the X axis.
                 * @param viewingConditions Information about the environment where the color
                 *     was observed.
                 */
                static fromUcsInViewingConditions(jstar, astar, bstar, viewingConditions) {
                    const a = astar;
                    const b = bstar;
                    const m = Math.sqrt(a * a + b * b);
                    const M = (Math.exp(m * 0.0228) - 1.0) / 0.0228;
                    const c = M / viewingConditions.fLRoot;
                    let h = Math.atan2(b, a) * (180.0 / Math.PI);
                    if (h < 0.0) {
                        h += 360.0;
                    }
                    const j = jstar / (1 - (jstar - 100) * 0.007);
                    return Cam16.fromJchInViewingConditions(j, c, h, viewingConditions);
                }
                /**
                 *  @return ARGB representation of color, assuming the color was viewed in
                 *     default viewing conditions, which are near-identical to the default
                 *     viewing conditions for sRGB.
                 */
                toInt() {
                    return this.viewed(viewing_conditions_1.ViewingConditions.DEFAULT);
                }
                /**
                 * @param viewingConditions Information about the environment where the color
                 *     will be viewed.
                 * @return ARGB representation of color
                 */
                viewed(viewingConditions) {
                    const alpha = this.chroma === 0.0 || this.j === 0.0 ?
                        0.0 :
                        this.chroma / Math.sqrt(this.j / 100.0);
                    const t = Math.pow(alpha / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73), 1.0 / 0.9);
                    const hRad = (this.hue * Math.PI) / 180.0;
                    const eHue = 0.25 * (Math.cos(hRad + 2.0) + 3.8);
                    const ac = viewingConditions.aw *
                        Math.pow(this.j / 100.0, 1.0 / viewingConditions.c / viewingConditions.z);
                    const p1 = eHue * (50000.0 / 13.0) * viewingConditions.nc * viewingConditions.ncb;
                    const p2 = ac / viewingConditions.nbb;
                    const hSin = Math.sin(hRad);
                    const hCos = Math.cos(hRad);
                    const gamma = (23.0 * (p2 + 0.305) * t) /
                        (23.0 * p1 + 11.0 * t * hCos + 108.0 * t * hSin);
                    const a = gamma * hCos;
                    const b = gamma * hSin;
                    const rA = (460.0 * p2 + 451.0 * a + 288.0 * b) / 1403.0;
                    const gA = (460.0 * p2 - 891.0 * a - 261.0 * b) / 1403.0;
                    const bA = (460.0 * p2 - 220.0 * a - 6300.0 * b) / 1403.0;
                    const rCBase = Math.max(0, (27.13 * Math.abs(rA)) / (400.0 - Math.abs(rA)));
                    const rC = math.signum(rA) * (100.0 / viewingConditions.fl) *
                        Math.pow(rCBase, 1.0 / 0.42);
                    const gCBase = Math.max(0, (27.13 * Math.abs(gA)) / (400.0 - Math.abs(gA)));
                    const gC = math.signum(gA) * (100.0 / viewingConditions.fl) *
                        Math.pow(gCBase, 1.0 / 0.42);
                    const bCBase = Math.max(0, (27.13 * Math.abs(bA)) / (400.0 - Math.abs(bA)));
                    const bC = math.signum(bA) * (100.0 / viewingConditions.fl) *
                        Math.pow(bCBase, 1.0 / 0.42);
                    const rF = rC / viewingConditions.rgbD[0];
                    const gF = gC / viewingConditions.rgbD[1];
                    const bF = bC / viewingConditions.rgbD[2];
                    const x = 1.86206786 * rF - 1.01125463 * gF + 0.14918677 * bF;
                    const y = 0.38752654 * rF + 0.62144744 * gF - 0.00897398 * bF;
                    const z = -0.01584150 * rF - 0.03412294 * gF + 1.04996444 * bF;
                    const argb = utils.argbFromXyz(x, y, z);
                    return argb;
                }
            };
            exports_4("Cam16", Cam16);
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("hct/hct_solver", ["utils/color_utils", "utils/math_utils", "hct/cam16", "hct/viewing_conditions"], function (exports_5, context_5) {
    "use strict";
    var colorUtils, mathUtils, cam16_1, viewing_conditions_2, HctSolver;
    var __moduleName = context_5 && context_5.id;
    return {
        setters: [
            function (colorUtils_1) {
                colorUtils = colorUtils_1;
            },
            function (mathUtils_2) {
                mathUtils = mathUtils_2;
            },
            function (cam16_1_1) {
                cam16_1 = cam16_1_1;
            },
            function (viewing_conditions_2_1) {
                viewing_conditions_2 = viewing_conditions_2_1;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            // libmonet is designed to have a consistent API across platforms
            // and modular components that can be moved around easily. Using a class as a
            // namespace facilitates this.
            //
            // tslint:disable:class-as-namespace
            /**
             * A class that solves the HCT equation.
             */
            HctSolver = class HctSolver {
                /**
                 * Sanitizes a small enough angle in radians.
                 *
                 * @param angle An angle in radians; must not deviate too much
                 * from 0.
                 * @return A coterminal angle between 0 and 2pi.
                 */
                static sanitizeRadians(angle) {
                    return (angle + Math.PI * 8) % (Math.PI * 2);
                }
                /**
                 * Delinearizes an RGB component, returning a floating-point
                 * number.
                 *
                 * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
                 * linear R/G/B channel
                 * @return 0.0 <= output <= 255.0, color channel converted to
                 * regular RGB space
                 */
                static trueDelinearized(rgbComponent) {
                    const normalized = rgbComponent / 100.0;
                    let delinearized = 0.0;
                    if (normalized <= 0.0031308) {
                        delinearized = normalized * 12.92;
                    }
                    else {
                        delinearized = 1.055 * Math.pow(normalized, 1.0 / 2.4) - 0.055;
                    }
                    return delinearized * 255.0;
                }
                static chromaticAdaptation(component) {
                    const af = Math.pow(Math.abs(component), 0.42);
                    return mathUtils.signum(component) * 400.0 * af / (af + 27.13);
                }
                /**
                 * Returns the hue of a linear RGB color in CAM16.
                 *
                 * @param linrgb The linear RGB coordinates of a color.
                 * @return The hue of the color in CAM16, in radians.
                 */
                static hueOf(linrgb) {
                    const scaledDiscount = mathUtils.matrixMultiply(linrgb, HctSolver.SCALED_DISCOUNT_FROM_LINRGB);
                    const rA = HctSolver.chromaticAdaptation(scaledDiscount[0]);
                    const gA = HctSolver.chromaticAdaptation(scaledDiscount[1]);
                    const bA = HctSolver.chromaticAdaptation(scaledDiscount[2]);
                    // redness-greenness
                    const a = (11.0 * rA + -12.0 * gA + bA) / 11.0;
                    // yellowness-blueness
                    const b = (rA + gA - 2.0 * bA) / 9.0;
                    return Math.atan2(b, a);
                }
                static areInCyclicOrder(a, b, c) {
                    const deltaAB = HctSolver.sanitizeRadians(b - a);
                    const deltaAC = HctSolver.sanitizeRadians(c - a);
                    return deltaAB < deltaAC;
                }
                /**
                 * Solves the lerp equation.
                 *
                 * @param source The starting number.
                 * @param mid The number in the middle.
                 * @param target The ending number.
                 * @return A number t such that lerp(source, target, t) = mid.
                 */
                static intercept(source, mid, target) {
                    return (mid - source) / (target - source);
                }
                static lerpPoint(source, t, target) {
                    return [
                        source[0] + (target[0] - source[0]) * t,
                        source[1] + (target[1] - source[1]) * t,
                        source[2] + (target[2] - source[2]) * t,
                    ];
                }
                /**
                 * Intersects a segment with a plane.
                 *
                 * @param source The coordinates of point A.
                 * @param coordinate The R-, G-, or B-coordinate of the plane.
                 * @param target The coordinates of point B.
                 * @param axis The axis the plane is perpendicular with. (0: R, 1:
                 * G, 2: B)
                 * @return The intersection point of the segment AB with the plane
                 * R=coordinate, G=coordinate, or B=coordinate
                 */
                static setCoordinate(source, coordinate, target, axis) {
                    const t = HctSolver.intercept(source[axis], coordinate, target[axis]);
                    return HctSolver.lerpPoint(source, t, target);
                }
                static isBounded(x) {
                    return 0.0 <= x && x <= 100.0;
                }
                /**
                 * Returns the nth possible vertex of the polygonal intersection.
                 *
                 * @param y The Y value of the plane.
                 * @param n The zero-based index of the point. 0 <= n <= 11.
                 * @return The nth possible vertex of the polygonal intersection
                 * of the y plane and the RGB cube, in linear RGB coordinates, if
                 * it exists. If this possible vertex lies outside of the cube,
                 * [-1.0, -1.0, -1.0] is returned.
                 */
                static nthVertex(y, n) {
                    const kR = HctSolver.Y_FROM_LINRGB[0];
                    const kG = HctSolver.Y_FROM_LINRGB[1];
                    const kB = HctSolver.Y_FROM_LINRGB[2];
                    const coordA = n % 4 <= 1 ? 0.0 : 100.0;
                    const coordB = n % 2 === 0 ? 0.0 : 100.0;
                    if (n < 4) {
                        const g = coordA;
                        const b = coordB;
                        const r = (y - g * kG - b * kB) / kR;
                        if (HctSolver.isBounded(r)) {
                            return [r, g, b];
                        }
                        else {
                            return [-1.0, -1.0, -1.0];
                        }
                    }
                    else if (n < 8) {
                        const b = coordA;
                        const r = coordB;
                        const g = (y - r * kR - b * kB) / kG;
                        if (HctSolver.isBounded(g)) {
                            return [r, g, b];
                        }
                        else {
                            return [-1.0, -1.0, -1.0];
                        }
                    }
                    else {
                        const r = coordA;
                        const g = coordB;
                        const b = (y - r * kR - g * kG) / kB;
                        if (HctSolver.isBounded(b)) {
                            return [r, g, b];
                        }
                        else {
                            return [-1.0, -1.0, -1.0];
                        }
                    }
                }
                /**
                 * Finds the segment containing the desired color.
                 *
                 * @param y The Y value of the color.
                 * @param targetHue The hue of the color.
                 * @return A list of two sets of linear RGB coordinates, each
                 * corresponding to an endpoint of the segment containing the
                 * desired color.
                 */
                static bisectToSegment(y, targetHue) {
                    let left = [-1.0, -1.0, -1.0];
                    let right = left;
                    let leftHue = 0.0;
                    let rightHue = 0.0;
                    let initialized = false;
                    let uncut = true;
                    for (let n = 0; n < 12; n++) {
                        const mid = HctSolver.nthVertex(y, n);
                        if (mid[0] < 0) {
                            continue;
                        }
                        const midHue = HctSolver.hueOf(mid);
                        if (!initialized) {
                            left = mid;
                            right = mid;
                            leftHue = midHue;
                            rightHue = midHue;
                            initialized = true;
                            continue;
                        }
                        if (uncut || HctSolver.areInCyclicOrder(leftHue, midHue, rightHue)) {
                            uncut = false;
                            if (HctSolver.areInCyclicOrder(leftHue, targetHue, midHue)) {
                                right = mid;
                                rightHue = midHue;
                            }
                            else {
                                left = mid;
                                leftHue = midHue;
                            }
                        }
                    }
                    return [left, right];
                }
                static midpoint(a, b) {
                    return [
                        (a[0] + b[0]) / 2,
                        (a[1] + b[1]) / 2,
                        (a[2] + b[2]) / 2,
                    ];
                }
                static criticalPlaneBelow(x) {
                    return Math.floor(x - 0.5);
                }
                static criticalPlaneAbove(x) {
                    return Math.ceil(x - 0.5);
                }
                /**
                 * Finds a color with the given Y and hue on the boundary of the
                 * cube.
                 *
                 * @param y The Y value of the color.
                 * @param targetHue The hue of the color.
                 * @return The desired color, in linear RGB coordinates.
                 */
                static bisectToLimit(y, targetHue) {
                    const segment = HctSolver.bisectToSegment(y, targetHue);
                    let left = segment[0];
                    let leftHue = HctSolver.hueOf(left);
                    let right = segment[1];
                    for (let axis = 0; axis < 3; axis++) {
                        if (left[axis] !== right[axis]) {
                            let lPlane = -1;
                            let rPlane = 255;
                            if (left[axis] < right[axis]) {
                                lPlane = HctSolver.criticalPlaneBelow(HctSolver.trueDelinearized(left[axis]));
                                rPlane = HctSolver.criticalPlaneAbove(HctSolver.trueDelinearized(right[axis]));
                            }
                            else {
                                lPlane = HctSolver.criticalPlaneAbove(HctSolver.trueDelinearized(left[axis]));
                                rPlane = HctSolver.criticalPlaneBelow(HctSolver.trueDelinearized(right[axis]));
                            }
                            for (let i = 0; i < 8; i++) {
                                if (Math.abs(rPlane - lPlane) <= 1) {
                                    break;
                                }
                                else {
                                    const mPlane = Math.floor((lPlane + rPlane) / 2.0);
                                    const midPlaneCoordinate = HctSolver.CRITICAL_PLANES[mPlane];
                                    const mid = HctSolver.setCoordinate(left, midPlaneCoordinate, right, axis);
                                    const midHue = HctSolver.hueOf(mid);
                                    if (HctSolver.areInCyclicOrder(leftHue, targetHue, midHue)) {
                                        right = mid;
                                        rPlane = mPlane;
                                    }
                                    else {
                                        left = mid;
                                        leftHue = midHue;
                                        lPlane = mPlane;
                                    }
                                }
                            }
                        }
                    }
                    return HctSolver.midpoint(left, right);
                }
                static inverseChromaticAdaptation(adapted) {
                    const adaptedAbs = Math.abs(adapted);
                    const base = Math.max(0, 27.13 * adaptedAbs / (400.0 - adaptedAbs));
                    return mathUtils.signum(adapted) * Math.pow(base, 1.0 / 0.42);
                }
                /**
                 * Finds a color with the given hue, chroma, and Y.
                 *
                 * @param hueRadians The desired hue in radians.
                 * @param chroma The desired chroma.
                 * @param y The desired Y.
                 * @return The desired color as a hexadecimal integer, if found; 0
                 * otherwise.
                 */
                static findResultByJ(hueRadians, chroma, y) {
                    // Initial estimate of j.
                    let j = Math.sqrt(y) * 11.0;
                    // ===========================================================
                    // Operations inlined from Cam16 to avoid repeated calculation
                    // ===========================================================
                    const viewingConditions = viewing_conditions_2.ViewingConditions.DEFAULT;
                    const tInnerCoeff = 1 / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73);
                    const eHue = 0.25 * (Math.cos(hueRadians + 2.0) + 3.8);
                    const p1 = eHue * (50000.0 / 13.0) * viewingConditions.nc * viewingConditions.ncb;
                    const hSin = Math.sin(hueRadians);
                    const hCos = Math.cos(hueRadians);
                    for (let iterationRound = 0; iterationRound < 5; iterationRound++) {
                        // ===========================================================
                        // Operations inlined from Cam16 to avoid repeated calculation
                        // ===========================================================
                        const jNormalized = j / 100.0;
                        const alpha = chroma === 0.0 || j === 0.0 ? 0.0 : chroma / Math.sqrt(jNormalized);
                        const t = Math.pow(alpha * tInnerCoeff, 1.0 / 0.9);
                        const ac = viewingConditions.aw *
                            Math.pow(jNormalized, 1.0 / viewingConditions.c / viewingConditions.z);
                        const p2 = ac / viewingConditions.nbb;
                        const gamma = 23.0 * (p2 + 0.305) * t /
                            (23.0 * p1 + 11 * t * hCos + 108.0 * t * hSin);
                        const a = gamma * hCos;
                        const b = gamma * hSin;
                        const rA = (460.0 * p2 + 451.0 * a + 288.0 * b) / 1403.0;
                        const gA = (460.0 * p2 - 891.0 * a - 261.0 * b) / 1403.0;
                        const bA = (460.0 * p2 - 220.0 * a - 6300.0 * b) / 1403.0;
                        const rCScaled = HctSolver.inverseChromaticAdaptation(rA);
                        const gCScaled = HctSolver.inverseChromaticAdaptation(gA);
                        const bCScaled = HctSolver.inverseChromaticAdaptation(bA);
                        const linrgb = mathUtils.matrixMultiply([rCScaled, gCScaled, bCScaled], HctSolver.LINRGB_FROM_SCALED_DISCOUNT);
                        // ===========================================================
                        // Operations inlined from Cam16 to avoid repeated calculation
                        // ===========================================================
                        if (linrgb[0] < 0 || linrgb[1] < 0 || linrgb[2] < 0) {
                            return 0;
                        }
                        const kR = HctSolver.Y_FROM_LINRGB[0];
                        const kG = HctSolver.Y_FROM_LINRGB[1];
                        const kB = HctSolver.Y_FROM_LINRGB[2];
                        const fnj = kR * linrgb[0] + kG * linrgb[1] + kB * linrgb[2];
                        if (fnj <= 0) {
                            return 0;
                        }
                        if (iterationRound === 4 || Math.abs(fnj - y) < 0.002) {
                            if (linrgb[0] > 100.01 || linrgb[1] > 100.01 || linrgb[2] > 100.01) {
                                return 0;
                            }
                            return colorUtils.argbFromLinrgb(linrgb);
                        }
                        // Iterates with Newton method,
                        // Using 2 * fn(j) / j as the approximation of fn'(j)
                        j = j - (fnj - y) * j / (2 * fnj);
                    }
                    return 0;
                }
                /**
                 * Finds an sRGB color with the given hue, chroma, and L*, if
                 * possible.
                 *
                 * @param hueDegrees The desired hue, in degrees.
                 * @param chroma The desired chroma.
                 * @param lstar The desired L*.
                 * @return A hexadecimal representing the sRGB color. The color
                 * has sufficiently close hue, chroma, and L* to the desired
                 * values, if possible; otherwise, the hue and L* will be
                 * sufficiently close, and chroma will be maximized.
                 */
                static solveToInt(hueDegrees, chroma, lstar) {
                    if (chroma < 0.0001 || lstar < 0.0001 || lstar > 99.9999) {
                        return colorUtils.argbFromLstar(lstar);
                    }
                    hueDegrees = mathUtils.sanitizeDegreesDouble(hueDegrees);
                    const hueRadians = hueDegrees / 180 * Math.PI;
                    const y = colorUtils.yFromLstar(lstar);
                    const exactAnswer = HctSolver.findResultByJ(hueRadians, chroma, y);
                    if (exactAnswer !== 0) {
                        return exactAnswer;
                    }
                    const linrgb = HctSolver.bisectToLimit(y, hueRadians);
                    return colorUtils.argbFromLinrgb(linrgb);
                }
                /**
                 * Finds an sRGB color with the given hue, chroma, and L*, if
                 * possible.
                 *
                 * @param hueDegrees The desired hue, in degrees.
                 * @param chroma The desired chroma.
                 * @param lstar The desired L*.
                 * @return An CAM16 object representing the sRGB color. The color
                 * has sufficiently close hue, chroma, and L* to the desired
                 * values, if possible; otherwise, the hue and L* will be
                 * sufficiently close, and chroma will be maximized.
                 */
                static solveToCam(hueDegrees, chroma, lstar) {
                    return cam16_1.Cam16.fromInt(HctSolver.solveToInt(hueDegrees, chroma, lstar));
                }
            };
            exports_5("HctSolver", HctSolver);
            HctSolver.SCALED_DISCOUNT_FROM_LINRGB = [
                [
                    0.001200833568784504,
                    0.002389694492170889,
                    0.0002795742885861124,
                ],
                [
                    0.0005891086651375999,
                    0.0029785502573438758,
                    0.0003270666104008398,
                ],
                [
                    0.00010146692491640572,
                    0.0005364214359186694,
                    0.0032979401770712076,
                ],
            ];
            HctSolver.LINRGB_FROM_SCALED_DISCOUNT = [
                [
                    1373.2198709594231,
                    -1100.4251190754821,
                    -7.278681089101213,
                ],
                [
                    -271.815969077903,
                    559.6580465940733,
                    -32.46047482791194,
                ],
                [
                    1.9622899599665666,
                    -57.173814538844006,
                    308.7233197812385,
                ],
            ];
            HctSolver.Y_FROM_LINRGB = [0.2126, 0.7152, 0.0722];
            HctSolver.CRITICAL_PLANES = [
                0.015176349177441876, 0.045529047532325624, 0.07588174588720938,
                0.10623444424209313, 0.13658714259697685, 0.16693984095186062,
                0.19729253930674434, 0.2276452376616281, 0.2579979360165119,
                0.28835063437139563, 0.3188300904430532, 0.350925934958123,
                0.3848314933096426, 0.42057480301049466, 0.458183274052838,
                0.4976837250274023, 0.5391024159806381, 0.5824650784040898,
                0.6277969426914107, 0.6751227633498623, 0.7244668422128921,
                0.775853049866786, 0.829304845476233, 0.8848452951698498,
                0.942497089126609, 1.0022825574869039, 1.0642236851973577,
                1.1283421258858297, 1.1946592148522128, 1.2631959812511864,
                1.3339731595349034, 1.407011200216447, 1.4823302800086415,
                1.5599503113873272, 1.6398909516233677, 1.7221716113234105,
                1.8068114625156377, 1.8938294463134073, 1.9832442801866852,
                2.075074464868551, 2.1693382909216234, 2.2660538449872063,
                2.36523901573795, 2.4669114995532007, 2.5710888059345764,
                2.6777882626779785, 2.7870270208169257, 2.898822059350997,
                3.0131901897720907, 3.1301480604002863, 3.2497121605402226,
                3.3718988244681087, 3.4967242352587946, 3.624204428461639,
                3.754355295633311, 3.887192587735158, 4.022731918402185,
                4.160988767090289, 4.301978482107941, 4.445716283538092,
                4.592217266055746, 4.741496401646282, 4.893568542229298,
                5.048448422192488, 5.20615066083972, 5.3666897647573375,
                5.5300801301023865, 5.696336044816294, 5.865471690767354,
                6.037501145825082, 6.212438385869475, 6.390297286737924,
                6.571091626112461, 6.7548350853498045, 6.941541251256611,
                7.131223617812143, 7.323895587840543, 7.5195704746346665,
                7.7182615035334345, 7.919981813454504, 8.124744458384042,
                8.332562408825165, 8.543448553206703, 8.757415699253682,
                8.974476575321063, 9.194643831691977, 9.417930041841839,
                9.644347703669503, 9.873909240696694, 10.106627003236781,
                10.342513269534024, 10.58158024687427, 10.8238400726681,
                11.069304815507364, 11.317986476196008, 11.569896988756009,
                11.825048221409341, 12.083451977536606, 12.345119996613247,
                12.610063955123938, 12.878295467455942, 13.149826086772048,
                13.42466730586372, 13.702830557985108, 13.984327217668513,
                14.269168601521828, 14.55736596900856, 14.848930523210871,
                15.143873411576273, 15.44220572664832, 15.743938506781891,
                16.04908273684337, 16.35764934889634, 16.66964922287304,
                16.985093187232053, 17.30399201960269, 17.62635644741625,
                17.95219714852476, 18.281524751807332, 18.614349837764564,
                18.95068293910138, 19.290534541298456, 19.633915083172692,
                19.98083495742689, 20.331304511189067, 20.685334046541502,
                21.042933821039977, 21.404114048223256, 21.76888489811322,
                22.137256497705877, 22.50923893145328, 22.884842241736916,
                23.264076429332462, 23.6469514538663, 24.033477234264016,
                24.42366364919083, 24.817520537484558, 25.21505769858089,
                25.61628489293138, 26.021211842414342, 26.429848230738664,
                26.842203703840827, 27.258287870275353, 27.678110301598522,
                28.10168053274597, 28.529008062403893, 28.96010235337422,
                29.39497283293396, 29.83362889318845, 30.276079891419332,
                30.722335150426627, 31.172403958865512, 31.62629557157785,
                32.08401920991837, 32.54558406207592, 33.010999283389665,
                33.4802739966603, 33.953417292456834, 34.430438229418264,
                34.911345834551085, 35.39614910352207, 35.88485700094671,
                36.37747846067349, 36.87402238606382, 37.37449765026789,
                37.87891309649659, 38.38727753828926, 38.89959975977785,
                39.41588851594697, 39.93615253289054, 40.460400508064545,
                40.98864111053629, 41.520882981230194, 42.05713473317016,
                42.597404951718396, 43.141702194811224, 43.6900349931913,
                44.24241185063697, 44.798841244188324, 45.35933162437017,
                45.92389141541209, 46.49252901546552, 47.065252796817916,
                47.64207110610409, 48.22299226451468, 48.808024568002054,
                49.3971762874833, 49.9904556690408, 50.587870934119984,
                51.189430279724725, 51.79514187861014, 52.40501387947288,
                53.0190544071392, 53.637271562750364, 54.259673423945976,
                54.88626804504493, 55.517063457223934, 56.15206766869424,
                56.79128866487574, 57.43473440856916, 58.08241284012621,
                58.734331877617365, 59.39049941699807, 60.05092333227251,
                60.715611475655585, 61.38457167773311, 62.057811747619894,
                62.7353394731159, 63.417162620860914, 64.10328893648692,
                64.79372614476921, 65.48848194977529, 66.18756403501224,
                66.89098006357258, 67.59873767827808, 68.31084450182222,
                69.02730813691093, 69.74813616640164, 70.47333615344107,
                71.20291564160104, 71.93688215501312, 72.67524319850172,
                73.41800625771542, 74.16517879925733, 74.9167682708136,
                75.67278210128072, 76.43322770089146, 77.1981124613393,
                77.96744375590167, 78.74122893956174, 79.51947534912904,
                80.30219030335869, 81.08938110306934, 81.88105503125999,
                82.67721935322541, 83.4778813166706, 84.28304815182372,
                85.09272707154808, 85.90692527145302, 86.72564993000343,
                87.54890820862819, 88.3767072518277, 89.2090541872801,
                90.04595612594655, 90.88742016217518, 91.73345337380438,
                92.58406282226491, 93.43925555268066, 94.29903859396902,
                95.16341895893969, 96.03240364439274, 96.9059996312159,
                97.78421388448044, 98.6670533535366, 99.55452497210776,
            ];
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("hct/hct", ["utils/color_utils", "hct/cam16", "hct/hct_solver"], function (exports_6, context_6) {
    "use strict";
    var utils, cam16_2, hct_solver_1, Hct;
    var __moduleName = context_6 && context_6.id;
    return {
        setters: [
            function (utils_3) {
                utils = utils_3;
            },
            function (cam16_2_1) {
                cam16_2 = cam16_2_1;
            },
            function (hct_solver_1_1) {
                hct_solver_1 = hct_solver_1_1;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * HCT, hue, chroma, and tone. A color system that provides a perceptually
             * accurate color measurement system that can also accurately render what colors
             * will appear as in different lighting environments.
             */
            Hct = class Hct {
                constructor(argb) {
                    this.argb = argb;
                    const cam = cam16_2.Cam16.fromInt(argb);
                    this.internalHue = cam.hue;
                    this.internalChroma = cam.chroma;
                    this.internalTone = utils.lstarFromArgb(argb);
                    this.argb = argb;
                }
                static from(hue, chroma, tone) {
                    return new Hct(hct_solver_1.HctSolver.solveToInt(hue, chroma, tone));
                }
                /**
                 * @param argb ARGB representation of a color.
                 * @return HCT representation of a color in default viewing conditions
                 */
                static fromInt(argb) {
                    return new Hct(argb);
                }
                toInt() {
                    return this.argb;
                }
                /**
                 * A number, in degrees, representing ex. red, orange, yellow, etc.
                 * Ranges from 0 <= hue < 360.
                 */
                get hue() {
                    return this.internalHue;
                }
                /**
                 * @param newHue 0 <= newHue < 360; invalid values are corrected.
                 * Chroma may decrease because chroma has a different maximum for any given
                 * hue and tone.
                 */
                set hue(newHue) {
                    this.setInternalState(hct_solver_1.HctSolver.solveToInt(newHue, this.internalChroma, this.internalTone));
                }
                get chroma() {
                    return this.internalChroma;
                }
                /**
                 * @param newChroma 0 <= newChroma < ?
                 * Chroma may decrease because chroma has a different maximum for any given
                 * hue and tone.
                 */
                set chroma(newChroma) {
                    this.setInternalState(hct_solver_1.HctSolver.solveToInt(this.internalHue, newChroma, this.internalTone));
                }
                /** Lightness. Ranges from 0 to 100. */
                get tone() {
                    return this.internalTone;
                }
                /**
                 * @param newTone 0 <= newTone <= 100; invalid valids are corrected.
                 * Chroma may decrease because chroma has a different maximum for any given
                 * hue and tone.
                 */
                set tone(newTone) {
                    this.setInternalState(hct_solver_1.HctSolver.solveToInt(this.internalHue, this.internalChroma, newTone));
                }
                setInternalState(argb) {
                    const cam = cam16_2.Cam16.fromInt(argb);
                    this.internalHue = cam.hue;
                    this.internalChroma = cam.chroma;
                    this.internalTone = utils.lstarFromArgb(argb);
                    this.argb = argb;
                }
            };
            exports_6("Hct", Hct);
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("blend/blend", ["hct/cam16", "hct/hct", "utils/color_utils", "utils/math_utils"], function (exports_7, context_7) {
    "use strict";
    var cam16_3, hct_1, colorUtils, mathUtils, Blend;
    var __moduleName = context_7 && context_7.id;
    return {
        setters: [
            function (cam16_3_1) {
                cam16_3 = cam16_3_1;
            },
            function (hct_1_1) {
                hct_1 = hct_1_1;
            },
            function (colorUtils_2) {
                colorUtils = colorUtils_2;
            },
            function (mathUtils_3) {
                mathUtils = mathUtils_3;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            // libmonet is designed to have a consistent API across platforms
            // and modular components that can be moved around easily. Using a class as a
            // namespace facilitates this.
            //
            // tslint:disable:class-as-namespace
            /**
             * Functions for blending in HCT and CAM16.
             */
            Blend = class Blend {
                /**
                 * Blend the design color's HCT hue towards the key color's HCT
                 * hue, in a way that leaves the original color recognizable and
                 * recognizably shifted towards the key color.
                 *
                 * @param designColor ARGB representation of an arbitrary color.
                 * @param sourceColor ARGB representation of the main theme color.
                 * @return The design color with a hue shifted towards the
                 * system's color, a slightly warmer/cooler variant of the design
                 * color's hue.
                 */
                static harmonize(designColor, sourceColor) {
                    const fromHct = hct_1.Hct.fromInt(designColor);
                    const toHct = hct_1.Hct.fromInt(sourceColor);
                    const differenceDegrees = mathUtils.differenceDegrees(fromHct.hue, toHct.hue);
                    const rotationDegrees = Math.min(differenceDegrees * 0.5, 15.0);
                    const outputHue = mathUtils.sanitizeDegreesDouble(fromHct.hue +
                        rotationDegrees * mathUtils.rotationDirection(fromHct.hue, toHct.hue));
                    return hct_1.Hct.from(outputHue, fromHct.chroma, fromHct.tone).toInt();
                }
                /**
                 * Blends hue from one color into another. The chroma and tone of
                 * the original color are maintained.
                 *
                 * @param from ARGB representation of color
                 * @param to ARGB representation of color
                 * @param amount how much blending to perform; 0.0 >= and <= 1.0
                 * @return from, with a hue blended towards to. Chroma and tone
                 * are constant.
                 */
                static hctHue(from, to, amount) {
                    const ucs = Blend.cam16Ucs(from, to, amount);
                    const ucsCam = cam16_3.Cam16.fromInt(ucs);
                    const fromCam = cam16_3.Cam16.fromInt(from);
                    const blended = hct_1.Hct.from(ucsCam.hue, fromCam.chroma, colorUtils.lstarFromArgb(from));
                    return blended.toInt();
                }
                /**
                 * Blend in CAM16-UCS space.
                 *
                 * @param from ARGB representation of color
                 * @param to ARGB representation of color
                 * @param amount how much blending to perform; 0.0 >= and <= 1.0
                 * @return from, blended towards to. Hue, chroma, and tone will
                 * change.
                 */
                static cam16Ucs(from, to, amount) {
                    const fromCam = cam16_3.Cam16.fromInt(from);
                    const toCam = cam16_3.Cam16.fromInt(to);
                    const fromJ = fromCam.jstar;
                    const fromA = fromCam.astar;
                    const fromB = fromCam.bstar;
                    const toJ = toCam.jstar;
                    const toA = toCam.astar;
                    const toB = toCam.bstar;
                    const jstar = fromJ + (toJ - fromJ) * amount;
                    const astar = fromA + (toA - fromA) * amount;
                    const bstar = fromB + (toB - fromB) * amount;
                    return cam16_3.Cam16.fromUcs(jstar, astar, bstar).toInt();
                }
            };
            exports_7("Blend", Blend);
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("palettes/tonal_palette", ["hct/hct"], function (exports_8, context_8) {
    "use strict";
    var hct_2, TonalPalette;
    var __moduleName = context_8 && context_8.id;
    return {
        setters: [
            function (hct_2_1) {
                hct_2 = hct_2_1;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             *  A convenience class for retrieving colors that are constant in hue and
             *  chroma, but vary in tone.
             */
            TonalPalette = class TonalPalette {
                constructor(hue, chroma) {
                    this.hue = hue;
                    this.chroma = chroma;
                    this.cache = new Map();
                }
                /**
                 * @param argb ARGB representation of a color
                 * @return Tones matching that color's hue and chroma.
                 */
                static fromInt(argb) {
                    const hct = hct_2.Hct.fromInt(argb);
                    return TonalPalette.fromHueAndChroma(hct.hue, hct.chroma);
                }
                /**
                 * @param hue HCT hue
                 * @param chroma HCT chroma
                 * @return Tones matching hue and chroma.
                 */
                static fromHueAndChroma(hue, chroma) {
                    return new TonalPalette(hue, chroma);
                }
                /**
                 * @param tone HCT tone, measured from 0 to 100.
                 * @return ARGB representation of a color with that tone.
                 */
                tone(tone) {
                    let argb = this.cache.get(tone);
                    if (argb === undefined) {
                        argb = hct_2.Hct.from(this.hue, this.chroma, tone).toInt();
                        this.cache.set(tone, argb);
                    }
                    return argb;
                }
            };
            exports_8("TonalPalette", TonalPalette);
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("palettes/core_palette", ["hct/hct", "palettes/tonal_palette"], function (exports_9, context_9) {
    "use strict";
    var hct_3, tonal_palette_1, CorePalette;
    var __moduleName = context_9 && context_9.id;
    return {
        setters: [
            function (hct_3_1) {
                hct_3 = hct_3_1;
            },
            function (tonal_palette_1_1) {
                tonal_palette_1 = tonal_palette_1_1;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * An intermediate concept between the key color for a UI theme, and a full
             * color scheme. 5 sets of tones are generated, all except one use the same hue
             * as the key color, and all vary in chroma.
             */
            CorePalette = class CorePalette {
                constructor(argb, isContent) {
                    const hct = hct_3.Hct.fromInt(argb);
                    const hue = hct.hue;
                    const chroma = hct.chroma;
                    if (isContent) {
                        this.a1 = tonal_palette_1.TonalPalette.fromHueAndChroma(hue, chroma);
                        this.a2 = tonal_palette_1.TonalPalette.fromHueAndChroma(hue, chroma / 3);
                        this.a3 = tonal_palette_1.TonalPalette.fromHueAndChroma(hue + 60, chroma / 2);
                        this.n1 = tonal_palette_1.TonalPalette.fromHueAndChroma(hue, Math.min(chroma / 12, 4));
                        this.n2 = tonal_palette_1.TonalPalette.fromHueAndChroma(hue, Math.min(chroma / 6, 8));
                    }
                    else {
                        this.a1 = tonal_palette_1.TonalPalette.fromHueAndChroma(hue, Math.max(48, chroma));
                        this.a2 = tonal_palette_1.TonalPalette.fromHueAndChroma(hue, 16);
                        this.a3 = tonal_palette_1.TonalPalette.fromHueAndChroma(hue + 60, 24);
                        this.n1 = tonal_palette_1.TonalPalette.fromHueAndChroma(hue, 4);
                        this.n2 = tonal_palette_1.TonalPalette.fromHueAndChroma(hue, 8);
                    }
                    this.error = tonal_palette_1.TonalPalette.fromHueAndChroma(25, 84);
                }
                /**
                 * @param argb ARGB representation of a color
                 */
                static of(argb) {
                    return new CorePalette(argb, false);
                }
                /**
                 * @param argb ARGB representation of a color
                 */
                static contentOf(argb) {
                    return new CorePalette(argb, true);
                }
            };
            exports_9("CorePalette", CorePalette);
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("quantize/quantizer_wsmeans", [], function (exports_10, context_10) {
    "use strict";
    var QuantizerWsmeans;
    var __moduleName = context_10 && context_10.id;
    return {
        setters: [],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            // import {LabPointProvider} from './lab_point_provider';
            // const MAX_ITERATIONS = 10;
            // const MIN_MOVEMENT_DISTANCE = 3.0;
            /**
             * An image quantizer that improves on the speed of a standard K-Means algorithm
             * by implementing several optimizations, including deduping identical pixels
             * and a triangle inequality rule that reduces the number of comparisons needed
             * to identify which cluster a point should be moved to.
             *
             * Wsmeans stands for Weighted Square Means.
             *
             * This algorithm was designed by M. Emre Celebi, and was found in their 2011
             * paper, Improving the Performance of K-Means for Color Quantization.
             * https://arxiv.org/abs/1101.0395
             */
            // libmonet is designed to have a consistent API across platforms
            // and modular components that can be moved around easily. Using a class as a
            // namespace facilitates this.
            //
            // tslint:disable-next-line:class-as-namespace
            QuantizerWsmeans = class QuantizerWsmeans {
                /**
                 * @param inputPixels Colors in ARGB format.
                 * @param startingClusters Defines the initial state of the quantizer. Passing
                 *     an empty array is fine, the implementation will create its own initial
                 *     state that leads to reproducible results for the same inputs.
                 *     Passing an array that is the result of Wu quantization leads to higher
                 *     quality results.
                 * @param maxColors The number of colors to divide the image into. A lower
                 *     number of colors may be returned.
                 * @return Colors in ARGB format.
                 */
                static quantize(inputPixels, startingClusters, maxColors) {
                }
            };
            exports_10("QuantizerWsmeans", QuantizerWsmeans);
            /**
             *  A wrapper for maintaining a table of distances between K-Means clusters.
             */
            // class DistanceAndIndex {
            //   distance: number = -1;
            //   index: number = -1;
            // }
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("quantize/quantizer_map", ["utils/color_utils"], function (exports_11, context_11) {
    "use strict";
    var utils, QuantizerMap;
    var __moduleName = context_11 && context_11.id;
    return {
        setters: [
            function (utils_4) {
                utils = utils_4;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * Quantizes an image into a map, with keys of ARGB colors, and values of the
             * number of times that color appears in the image.
             */
            // libmonet is designed to have a consistent API across platforms
            // and modular components that can be moved around easily. Using a class as a
            // namespace facilitates this.
            //
            // tslint:disable-next-line:class-as-namespace
            QuantizerMap = class QuantizerMap {
                /**
                 * @param pixels Colors in ARGB format.
                 * @return A Map with keys of ARGB colors, and values of the number of times
                 *     the color appears in the image.
                 */
                static quantize(pixels) {
                    var _a;
                    const countByColor = new Map();
                    for (let i = 0; i < pixels.length; i++) {
                        const pixel = pixels[i];
                        const alpha = utils.alphaFromArgb(pixel);
                        if (alpha < 255) {
                            continue;
                        }
                        countByColor.set(pixel, ((_a = countByColor.get(pixel)) !== null && _a !== void 0 ? _a : 0) + 1);
                    }
                    return countByColor;
                }
            };
            exports_11("QuantizerMap", QuantizerMap);
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("quantize/quantizer_wu", ["utils/color_utils", "quantize/quantizer_map"], function (exports_12, context_12) {
    "use strict";
    var utils, quantizer_map_1, INDEX_BITS, SIDE_LENGTH, TOTAL_SIZE, directions, QuantizerWu, Box, CreateBoxesResult, MaximizeResult;
    var __moduleName = context_12 && context_12.id;
    return {
        setters: [
            function (utils_5) {
                utils = utils_5;
            },
            function (quantizer_map_1_1) {
                quantizer_map_1 = quantizer_map_1_1;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            INDEX_BITS = 5;
            SIDE_LENGTH = 33; // ((1 << INDEX_INDEX_BITS) + 1)
            TOTAL_SIZE = 35937; // SIDE_LENGTH * SIDE_LENGTH * SIDE_LENGTH
            directions = {
                RED: 'red',
                GREEN: 'green',
                BLUE: 'blue',
            };
            /**
             * An image quantizer that divides the image's pixels into clusters by
             * recursively cutting an RGB cube, based on the weight of pixels in each area
             * of the cube.
             *
             * The algorithm was described by Xiaolin Wu in Graphic Gems II, published in
             * 1991.
             */
            QuantizerWu = class QuantizerWu {
                constructor(weights = [], momentsR = [], momentsG = [], momentsB = [], moments = [], cubes = []) {
                    this.weights = weights;
                    this.momentsR = momentsR;
                    this.momentsG = momentsG;
                    this.momentsB = momentsB;
                    this.moments = moments;
                    this.cubes = cubes;
                }
                /**
                 * @param pixels Colors in ARGB format.
                 * @param maxColors The number of colors to divide the image into. A lower
                 *     number of colors may be returned.
                 * @return Colors in ARGB format.
                 */
                quantize(pixels, maxColors) {
                    this.constructHistogram(pixels);
                    this.computeMoments();
                    const createBoxesResult = this.createBoxes(maxColors);
                    const results = this.createResult(createBoxesResult.resultCount);
                    return results;
                }
                constructHistogram(pixels) {
                    var _a;
                    this.weights = Array.from({ length: TOTAL_SIZE }).fill(0);
                    this.momentsR = Array.from({ length: TOTAL_SIZE }).fill(0);
                    this.momentsG = Array.from({ length: TOTAL_SIZE }).fill(0);
                    this.momentsB = Array.from({ length: TOTAL_SIZE }).fill(0);
                    this.moments = Array.from({ length: TOTAL_SIZE }).fill(0);
                    const countByColor = quantizer_map_1.QuantizerMap.quantize(pixels);
                    for (const [pixel, count] of countByColor.entries()) {
                        const red = utils.redFromArgb(pixel);
                        const green = utils.greenFromArgb(pixel);
                        const blue = utils.blueFromArgb(pixel);
                        const bitsToRemove = 8 - INDEX_BITS;
                        const iR = (red >> bitsToRemove) + 1;
                        const iG = (green >> bitsToRemove) + 1;
                        const iB = (blue >> bitsToRemove) + 1;
                        const index = this.getIndex(iR, iG, iB);
                        this.weights[index] = ((_a = this.weights[index]) !== null && _a !== void 0 ? _a : 0) + count;
                        this.momentsR[index] += count * red;
                        this.momentsG[index] += count * green;
                        this.momentsB[index] += count * blue;
                        this.moments[index] += count * (red * red + green * green + blue * blue);
                    }
                }
                computeMoments() {
                    for (let r = 1; r < SIDE_LENGTH; r++) {
                        const area = Array.from({ length: SIDE_LENGTH }).fill(0);
                        const areaR = Array.from({ length: SIDE_LENGTH }).fill(0);
                        const areaG = Array.from({ length: SIDE_LENGTH }).fill(0);
                        const areaB = Array.from({ length: SIDE_LENGTH }).fill(0);
                        const area2 = Array.from({ length: SIDE_LENGTH }).fill(0.0);
                        for (let g = 1; g < SIDE_LENGTH; g++) {
                            let line = 0;
                            let lineR = 0;
                            let lineG = 0;
                            let lineB = 0;
                            let line2 = 0.0;
                            for (let b = 1; b < SIDE_LENGTH; b++) {
                                const index = this.getIndex(r, g, b);
                                line += this.weights[index];
                                lineR += this.momentsR[index];
                                lineG += this.momentsG[index];
                                lineB += this.momentsB[index];
                                line2 += this.moments[index];
                                area[b] += line;
                                areaR[b] += lineR;
                                areaG[b] += lineG;
                                areaB[b] += lineB;
                                area2[b] += line2;
                                const previousIndex = this.getIndex(r - 1, g, b);
                                this.weights[index] = this.weights[previousIndex] + area[b];
                                this.momentsR[index] = this.momentsR[previousIndex] + areaR[b];
                                this.momentsG[index] = this.momentsG[previousIndex] + areaG[b];
                                this.momentsB[index] = this.momentsB[previousIndex] + areaB[b];
                                this.moments[index] = this.moments[previousIndex] + area2[b];
                            }
                        }
                    }
                }
                createBoxes(maxColors) {
                    this.cubes =
                        Array.from({ length: maxColors }).fill(0).map(() => new Box());
                    const volumeVariance = Array.from({ length: maxColors }).fill(0.0);
                    this.cubes[0].r0 = 0;
                    this.cubes[0].g0 = 0;
                    this.cubes[0].b0 = 0;
                    this.cubes[0].r1 = SIDE_LENGTH - 1;
                    this.cubes[0].g1 = SIDE_LENGTH - 1;
                    this.cubes[0].b1 = SIDE_LENGTH - 1;
                    let generatedColorCount = maxColors;
                    let next = 0;
                    for (let i = 1; i < maxColors; i++) {
                        if (this.cut(this.cubes[next], this.cubes[i])) {
                            volumeVariance[next] =
                                this.cubes[next].vol > 1 ? this.variance(this.cubes[next]) : 0.0;
                            volumeVariance[i] =
                                this.cubes[i].vol > 1 ? this.variance(this.cubes[i]) : 0.0;
                        }
                        else {
                            volumeVariance[next] = 0.0;
                            i--;
                        }
                        next = 0;
                        let temp = volumeVariance[0];
                        for (let j = 1; j <= i; j++) {
                            if (volumeVariance[j] > temp) {
                                temp = volumeVariance[j];
                                next = j;
                            }
                        }
                        if (temp <= 0.0) {
                            generatedColorCount = i + 1;
                            break;
                        }
                    }
                    return new CreateBoxesResult(maxColors, generatedColorCount);
                }
                createResult(colorCount) {
                    const colors = [];
                    for (let i = 0; i < colorCount; ++i) {
                        const cube = this.cubes[i];
                        const weight = this.volume(cube, this.weights);
                        if (weight > 0) {
                            const r = Math.round(this.volume(cube, this.momentsR) / weight);
                            const g = Math.round(this.volume(cube, this.momentsG) / weight);
                            const b = Math.round(this.volume(cube, this.momentsB) / weight);
                            const color = (255 << 24) | ((r & 0x0ff) << 16) | ((g & 0x0ff) << 8) |
                                (b & 0x0ff);
                            colors.push(color);
                        }
                    }
                    return colors;
                }
                variance(cube) {
                    const dr = this.volume(cube, this.momentsR);
                    const dg = this.volume(cube, this.momentsG);
                    const db = this.volume(cube, this.momentsB);
                    const xx = this.moments[this.getIndex(cube.r1, cube.g1, cube.b1)] -
                        this.moments[this.getIndex(cube.r1, cube.g1, cube.b0)] -
                        this.moments[this.getIndex(cube.r1, cube.g0, cube.b1)] +
                        this.moments[this.getIndex(cube.r1, cube.g0, cube.b0)] -
                        this.moments[this.getIndex(cube.r0, cube.g1, cube.b1)] +
                        this.moments[this.getIndex(cube.r0, cube.g1, cube.b0)] +
                        this.moments[this.getIndex(cube.r0, cube.g0, cube.b1)] -
                        this.moments[this.getIndex(cube.r0, cube.g0, cube.b0)];
                    const hypotenuse = dr * dr + dg * dg + db * db;
                    const volume = this.volume(cube, this.weights);
                    return xx - hypotenuse / volume;
                }
                cut(one, two) {
                    const wholeR = this.volume(one, this.momentsR);
                    const wholeG = this.volume(one, this.momentsG);
                    const wholeB = this.volume(one, this.momentsB);
                    const wholeW = this.volume(one, this.weights);
                    const maxRResult = this.maximize(one, directions.RED, one.r0 + 1, one.r1, wholeR, wholeG, wholeB, wholeW);
                    const maxGResult = this.maximize(one, directions.GREEN, one.g0 + 1, one.g1, wholeR, wholeG, wholeB, wholeW);
                    const maxBResult = this.maximize(one, directions.BLUE, one.b0 + 1, one.b1, wholeR, wholeG, wholeB, wholeW);
                    let direction;
                    const maxR = maxRResult.maximum;
                    const maxG = maxGResult.maximum;
                    const maxB = maxBResult.maximum;
                    if (maxR >= maxG && maxR >= maxB) {
                        if (maxRResult.cutLocation < 0) {
                            return false;
                        }
                        direction = directions.RED;
                    }
                    else if (maxG >= maxR && maxG >= maxB) {
                        direction = directions.GREEN;
                    }
                    else {
                        direction = directions.BLUE;
                    }
                    two.r1 = one.r1;
                    two.g1 = one.g1;
                    two.b1 = one.b1;
                    switch (direction) {
                        case directions.RED:
                            one.r1 = maxRResult.cutLocation;
                            two.r0 = one.r1;
                            two.g0 = one.g0;
                            two.b0 = one.b0;
                            break;
                        case directions.GREEN:
                            one.g1 = maxGResult.cutLocation;
                            two.r0 = one.r0;
                            two.g0 = one.g1;
                            two.b0 = one.b0;
                            break;
                        case directions.BLUE:
                            one.b1 = maxBResult.cutLocation;
                            two.r0 = one.r0;
                            two.g0 = one.g0;
                            two.b0 = one.b1;
                            break;
                        default:
                            throw new Error('unexpected direction ' + direction);
                    }
                    one.vol = (one.r1 - one.r0) * (one.g1 - one.g0) * (one.b1 - one.b0);
                    two.vol = (two.r1 - two.r0) * (two.g1 - two.g0) * (two.b1 - two.b0);
                    return true;
                }
                maximize(cube, direction, first, last, wholeR, wholeG, wholeB, wholeW) {
                    const bottomR = this.bottom(cube, direction, this.momentsR);
                    const bottomG = this.bottom(cube, direction, this.momentsG);
                    const bottomB = this.bottom(cube, direction, this.momentsB);
                    const bottomW = this.bottom(cube, direction, this.weights);
                    let max = 0.0;
                    let cut = -1;
                    let halfR = 0;
                    let halfG = 0;
                    let halfB = 0;
                    let halfW = 0;
                    for (let i = first; i < last; i++) {
                        halfR = bottomR + this.top(cube, direction, i, this.momentsR);
                        halfG = bottomG + this.top(cube, direction, i, this.momentsG);
                        halfB = bottomB + this.top(cube, direction, i, this.momentsB);
                        halfW = bottomW + this.top(cube, direction, i, this.weights);
                        if (halfW === 0) {
                            continue;
                        }
                        let tempNumerator = (halfR * halfR + halfG * halfG + halfB * halfB) * 1.0;
                        let tempDenominator = halfW * 1.0;
                        let temp = tempNumerator / tempDenominator;
                        halfR = wholeR - halfR;
                        halfG = wholeG - halfG;
                        halfB = wholeB - halfB;
                        halfW = wholeW - halfW;
                        if (halfW === 0) {
                            continue;
                        }
                        tempNumerator = (halfR * halfR + halfG * halfG + halfB * halfB) * 1.0;
                        tempDenominator = halfW * 1.0;
                        temp += tempNumerator / tempDenominator;
                        if (temp > max) {
                            max = temp;
                            cut = i;
                        }
                    }
                    return new MaximizeResult(cut, max);
                }
                volume(cube, moment) {
                    return (moment[this.getIndex(cube.r1, cube.g1, cube.b1)] -
                        moment[this.getIndex(cube.r1, cube.g1, cube.b0)] -
                        moment[this.getIndex(cube.r1, cube.g0, cube.b1)] +
                        moment[this.getIndex(cube.r1, cube.g0, cube.b0)] -
                        moment[this.getIndex(cube.r0, cube.g1, cube.b1)] +
                        moment[this.getIndex(cube.r0, cube.g1, cube.b0)] +
                        moment[this.getIndex(cube.r0, cube.g0, cube.b1)] -
                        moment[this.getIndex(cube.r0, cube.g0, cube.b0)]);
                }
                bottom(cube, direction, moment) {
                    switch (direction) {
                        case directions.RED:
                            return (-moment[this.getIndex(cube.r0, cube.g1, cube.b1)] +
                                moment[this.getIndex(cube.r0, cube.g1, cube.b0)] +
                                moment[this.getIndex(cube.r0, cube.g0, cube.b1)] -
                                moment[this.getIndex(cube.r0, cube.g0, cube.b0)]);
                        case directions.GREEN:
                            return (-moment[this.getIndex(cube.r1, cube.g0, cube.b1)] +
                                moment[this.getIndex(cube.r1, cube.g0, cube.b0)] +
                                moment[this.getIndex(cube.r0, cube.g0, cube.b1)] -
                                moment[this.getIndex(cube.r0, cube.g0, cube.b0)]);
                        case directions.BLUE:
                            return (-moment[this.getIndex(cube.r1, cube.g1, cube.b0)] +
                                moment[this.getIndex(cube.r1, cube.g0, cube.b0)] +
                                moment[this.getIndex(cube.r0, cube.g1, cube.b0)] -
                                moment[this.getIndex(cube.r0, cube.g0, cube.b0)]);
                        default:
                            throw new Error('unexpected direction $direction');
                    }
                }
                top(cube, direction, position, moment) {
                    switch (direction) {
                        case directions.RED:
                            return (moment[this.getIndex(position, cube.g1, cube.b1)] -
                                moment[this.getIndex(position, cube.g1, cube.b0)] -
                                moment[this.getIndex(position, cube.g0, cube.b1)] +
                                moment[this.getIndex(position, cube.g0, cube.b0)]);
                        case directions.GREEN:
                            return (moment[this.getIndex(cube.r1, position, cube.b1)] -
                                moment[this.getIndex(cube.r1, position, cube.b0)] -
                                moment[this.getIndex(cube.r0, position, cube.b1)] +
                                moment[this.getIndex(cube.r0, position, cube.b0)]);
                        case directions.BLUE:
                            return (moment[this.getIndex(cube.r1, cube.g1, position)] -
                                moment[this.getIndex(cube.r1, cube.g0, position)] -
                                moment[this.getIndex(cube.r0, cube.g1, position)] +
                                moment[this.getIndex(cube.r0, cube.g0, position)]);
                        default:
                            throw new Error('unexpected direction $direction');
                    }
                }
                getIndex(r, g, b) {
                    return (r << (INDEX_BITS * 2)) + (r << (INDEX_BITS + 1)) + r +
                        (g << INDEX_BITS) + g + b;
                }
            };
            exports_12("QuantizerWu", QuantizerWu);
            /**
             * Keeps track of the state of each box created as the Wu  quantization
             * algorithm progresses through dividing the image's pixels as plotted in RGB.
             */
            Box = class Box {
                constructor(r0 = 0, r1 = 0, g0 = 0, g1 = 0, b0 = 0, b1 = 0, vol = 0) {
                    this.r0 = r0;
                    this.r1 = r1;
                    this.g0 = g0;
                    this.g1 = g1;
                    this.b0 = b0;
                    this.b1 = b1;
                    this.vol = vol;
                }
            };
            /**
             * Represents final result of Wu algorithm.
             */
            CreateBoxesResult = class CreateBoxesResult {
                /**
                 * @param requestedCount how many colors the caller asked to be returned from
                 *     quantization.
                 * @param resultCount the actual number of colors achieved from quantization.
                 *     May be lower than the requested count.
                 */
                constructor(requestedCount, resultCount) {
                    this.requestedCount = requestedCount;
                    this.resultCount = resultCount;
                }
            };
            /**
             * Represents the result of calculating where to cut an existing box in such
             * a way to maximize variance between the two new boxes created by a cut.
             */
            MaximizeResult = class MaximizeResult {
                constructor(cutLocation, maximum) {
                    this.cutLocation = cutLocation;
                    this.maximum = maximum;
                }
            };
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("quantize/quantizer_celebi", ["quantize/quantizer_wsmeans", "quantize/quantizer_wu"], function (exports_13, context_13) {
    "use strict";
    var quantizer_wsmeans_1, quantizer_wu_1, QuantizerCelebi;
    var __moduleName = context_13 && context_13.id;
    return {
        setters: [
            function (quantizer_wsmeans_1_1) {
                quantizer_wsmeans_1 = quantizer_wsmeans_1_1;
            },
            function (quantizer_wu_1_1) {
                quantizer_wu_1 = quantizer_wu_1_1;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * An image quantizer that improves on the quality of a standard K-Means
             * algorithm by setting the K-Means initial state to the output of a Wu
             * quantizer, instead of random centroids. Improves on speed by several
             * optimizations, as implemented in Wsmeans, or Weighted Square Means, K-Means
             * with those optimizations.
             *
             * This algorithm was designed by M. Emre Celebi, and was found in their 2011
             * paper, Improving the Performance of K-Means for Color Quantization.
             * https://arxiv.org/abs/1101.0395
             */
            // libmonet is designed to have a consistent API across platforms
            // and modular components that can be moved around easily. Using a class as a
            // namespace facilitates this.
            //
            // tslint:disable-next-line:class-as-namespace
            QuantizerCelebi = class QuantizerCelebi {
                /**
                 * @param pixels Colors in ARGB format.
                 * @param maxColors The number of colors to divide the image into. A lower
                 *     number of colors may be returned.
                 * @return Map with keys of colors in ARGB format, and values of number of
                 *     pixels in the original image that correspond to the color in the
                 *     quantized image.
                 */
                static quantize(pixels, maxColors) {
                    const wu = new quantizer_wu_1.QuantizerWu();
                    const wuResult = wu.quantize(pixels, maxColors);
                    return quantizer_wsmeans_1.QuantizerWsmeans.quantize(pixels, wuResult, maxColors);
                }
            };
            exports_13("QuantizerCelebi", QuantizerCelebi);
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("scheme/scheme", ["palettes/core_palette"], function (exports_14, context_14) {
    "use strict";
    var core_palette_1, Scheme;
    var __moduleName = context_14 && context_14.id;
    return {
        setters: [
            function (core_palette_1_1) {
                core_palette_1 = core_palette_1_1;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * Represents a Material color scheme, a mapping of color roles to colors.
             */
            Scheme = class Scheme {
                constructor(props) {
                    this.props = props;
                }
                get primary() {
                    return this.props.primary;
                }
                get onPrimary() {
                    return this.props.onPrimary;
                }
                get primaryContainer() {
                    return this.props.primaryContainer;
                }
                get onPrimaryContainer() {
                    return this.props.onPrimaryContainer;
                }
                get secondary() {
                    return this.props.secondary;
                }
                get onSecondary() {
                    return this.props.onSecondary;
                }
                get secondaryContainer() {
                    return this.props.secondaryContainer;
                }
                get onSecondaryContainer() {
                    return this.props.onSecondaryContainer;
                }
                get tertiary() {
                    return this.props.tertiary;
                }
                get onTertiary() {
                    return this.props.onTertiary;
                }
                get tertiaryContainer() {
                    return this.props.tertiaryContainer;
                }
                get onTertiaryContainer() {
                    return this.props.onTertiaryContainer;
                }
                get error() {
                    return this.props.error;
                }
                get onError() {
                    return this.props.onError;
                }
                get errorContainer() {
                    return this.props.errorContainer;
                }
                get onErrorContainer() {
                    return this.props.onErrorContainer;
                }
                get background() {
                    return this.props.background;
                }
                get onBackground() {
                    return this.props.onBackground;
                }
                get surface() {
                    return this.props.surface;
                }
                get onSurface() {
                    return this.props.onSurface;
                }
                get surfaceVariant() {
                    return this.props.surfaceVariant;
                }
                get onSurfaceVariant() {
                    return this.props.onSurfaceVariant;
                }
                get outline() {
                    return this.props.outline;
                }
                get shadow() {
                    return this.props.shadow;
                }
                get inverseSurface() {
                    return this.props.inverseSurface;
                }
                get inverseOnSurface() {
                    return this.props.inverseOnSurface;
                }
                get inversePrimary() {
                    return this.props.inversePrimary;
                }
                /**
                 * @param argb ARGB representation of a color.
                 * @return Light Material color scheme, based on the color's hue.
                 */
                static light(argb) {
                    return Scheme.lightFromCorePalette(core_palette_1.CorePalette.of(argb));
                }
                /**
                 * @param argb ARGB representation of a color.
                 * @return Dark Material color scheme, based on the color's hue.
                 */
                static dark(argb) {
                    return Scheme.darkFromCorePalette(core_palette_1.CorePalette.of(argb));
                }
                /**
                 * @param argb ARGB representation of a color.
                 * @return Light Material content color scheme, based on the color's hue.
                 */
                static lightContent(argb) {
                    return Scheme.lightFromCorePalette(core_palette_1.CorePalette.contentOf(argb));
                }
                /**
                 * @param argb ARGB representation of a color.
                 * @return Dark Material content color scheme, based on the color's hue.
                 */
                static darkContent(argb) {
                    return Scheme.darkFromCorePalette(core_palette_1.CorePalette.contentOf(argb));
                }
                /**
                 * Light scheme from core palette
                 */
                static lightFromCorePalette(core) {
                    return new Scheme({
                        primary: core.a1.tone(40),
                        onPrimary: core.a1.tone(100),
                        primaryContainer: core.a1.tone(90),
                        onPrimaryContainer: core.a1.tone(10),
                        secondary: core.a2.tone(40),
                        onSecondary: core.a2.tone(100),
                        secondaryContainer: core.a2.tone(90),
                        onSecondaryContainer: core.a2.tone(10),
                        tertiary: core.a3.tone(40),
                        onTertiary: core.a3.tone(100),
                        tertiaryContainer: core.a3.tone(90),
                        onTertiaryContainer: core.a3.tone(10),
                        error: core.error.tone(40),
                        onError: core.error.tone(100),
                        errorContainer: core.error.tone(90),
                        onErrorContainer: core.error.tone(10),
                        background: core.n1.tone(99),
                        onBackground: core.n1.tone(10),
                        surface: core.n1.tone(99),
                        onSurface: core.n1.tone(10),
                        surfaceVariant: core.n2.tone(90),
                        onSurfaceVariant: core.n2.tone(30),
                        outline: core.n2.tone(50),
                        shadow: core.n1.tone(0),
                        inverseSurface: core.n1.tone(20),
                        inverseOnSurface: core.n1.tone(95),
                        inversePrimary: core.a1.tone(80)
                    });
                }
                /**
                 * Dark scheme from core palette
                 */
                static darkFromCorePalette(core) {
                    return new Scheme({
                        primary: core.a1.tone(80),
                        onPrimary: core.a1.tone(20),
                        primaryContainer: core.a1.tone(30),
                        onPrimaryContainer: core.a1.tone(90),
                        secondary: core.a2.tone(80),
                        onSecondary: core.a2.tone(20),
                        secondaryContainer: core.a2.tone(30),
                        onSecondaryContainer: core.a2.tone(90),
                        tertiary: core.a3.tone(80),
                        onTertiary: core.a3.tone(20),
                        tertiaryContainer: core.a3.tone(30),
                        onTertiaryContainer: core.a3.tone(90),
                        error: core.error.tone(80),
                        onError: core.error.tone(20),
                        errorContainer: core.error.tone(30),
                        onErrorContainer: core.error.tone(80),
                        background: core.n1.tone(10),
                        onBackground: core.n1.tone(90),
                        surface: core.n1.tone(10),
                        onSurface: core.n1.tone(90),
                        surfaceVariant: core.n2.tone(30),
                        onSurfaceVariant: core.n2.tone(80),
                        outline: core.n2.tone(60),
                        shadow: core.n1.tone(0),
                        inverseSurface: core.n1.tone(90),
                        inverseOnSurface: core.n1.tone(20),
                        inversePrimary: core.a1.tone(40)
                    });
                }
                toJSON() {
                    return Object.assign({}, this.props);
                }
            };
            exports_14("Scheme", Scheme);
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("scheme/scheme_android", ["palettes/core_palette"], function (exports_15, context_15) {
    "use strict";
    var core_palette_2, SchemeAndroid;
    var __moduleName = context_15 && context_15.id;
    return {
        setters: [
            function (core_palette_2_1) {
                core_palette_2 = core_palette_2_1;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * Represents an Android 12 color scheme, a mapping of color roles to colors.
             */
            SchemeAndroid = class SchemeAndroid {
                constructor(props) {
                    this.props = props;
                }
                get colorAccentPrimary() {
                    return this.props.colorAccentPrimary;
                }
                get colorAccentPrimaryVariant() {
                    return this.props.colorAccentPrimaryVariant;
                }
                get colorAccentSecondary() {
                    return this.props.colorAccentSecondary;
                }
                get colorAccentSecondaryVariant() {
                    return this.props.colorAccentSecondaryVariant;
                }
                get colorAccentTertiary() {
                    return this.props.colorAccentTertiary;
                }
                get colorAccentTertiaryVariant() {
                    return this.props.colorAccentTertiaryVariant;
                }
                get textColorPrimary() {
                    return this.props.textColorPrimary;
                }
                get textColorSecondary() {
                    return this.props.textColorSecondary;
                }
                get textColorTertiary() {
                    return this.props.textColorTertiary;
                }
                get textColorPrimaryInverse() {
                    return this.props.textColorPrimaryInverse;
                }
                get textColorSecondaryInverse() {
                    return this.props.textColorSecondaryInverse;
                }
                get textColorTertiaryInverse() {
                    return this.props.textColorTertiaryInverse;
                }
                get colorBackground() {
                    return this.props.colorBackground;
                }
                get colorBackgroundFloating() {
                    return this.props.colorBackgroundFloating;
                }
                get colorSurface() {
                    return this.props.colorSurface;
                }
                get colorSurfaceVariant() {
                    return this.props.colorSurfaceVariant;
                }
                get colorSurfaceHighlight() {
                    return this.props.colorSurfaceHighlight;
                }
                get surfaceHeader() {
                    return this.props.surfaceHeader;
                }
                get underSurface() {
                    return this.props.underSurface;
                }
                get offState() {
                    return this.props.offState;
                }
                get accentSurface() {
                    return this.props.accentSurface;
                }
                get textPrimaryOnAccent() {
                    return this.props.textPrimaryOnAccent;
                }
                get textSecondaryOnAccent() {
                    return this.props.textSecondaryOnAccent;
                }
                get volumeBackground() {
                    return this.props.volumeBackground;
                }
                get scrim() {
                    return this.props.scrim;
                }
                /**
                 * @param argb ARGB representation of a color.
                 * @return Light Material color scheme, based on the color's hue.
                 */
                static light(argb) {
                    const core = core_palette_2.CorePalette.of(argb);
                    return SchemeAndroid.lightFromCorePalette(core);
                }
                /**
                 * @param argb ARGB representation of a color.
                 * @return Dark Material color scheme, based on the color's hue.
                 */
                static dark(argb) {
                    const core = core_palette_2.CorePalette.of(argb);
                    return SchemeAndroid.darkFromCorePalette(core);
                }
                /**
                 * @param argb ARGB representation of a color.
                 * @return Light Android color scheme, based on the color's hue.
                 */
                static lightContent(argb) {
                    const core = core_palette_2.CorePalette.contentOf(argb);
                    return SchemeAndroid.lightFromCorePalette(core);
                }
                /**
                 * @param argb ARGB representation of a color.
                 * @return Dark Android color scheme, based on the color's hue.
                 */
                static darkContent(argb) {
                    const core = core_palette_2.CorePalette.contentOf(argb);
                    return SchemeAndroid.darkFromCorePalette(core);
                }
                /**
                 * Light scheme from core palette
                 */
                static lightFromCorePalette(core) {
                    return new SchemeAndroid({
                        colorAccentPrimary: core.a1.tone(90),
                        colorAccentPrimaryVariant: core.a1.tone(40),
                        colorAccentSecondary: core.a2.tone(90),
                        colorAccentSecondaryVariant: core.a2.tone(40),
                        colorAccentTertiary: core.a3.tone(90),
                        colorAccentTertiaryVariant: core.a3.tone(40),
                        textColorPrimary: core.n1.tone(10),
                        textColorSecondary: core.n2.tone(30),
                        textColorTertiary: core.n2.tone(50),
                        textColorPrimaryInverse: core.n1.tone(95),
                        textColorSecondaryInverse: core.n1.tone(80),
                        textColorTertiaryInverse: core.n1.tone(60),
                        colorBackground: core.n1.tone(95),
                        colorBackgroundFloating: core.n1.tone(98),
                        colorSurface: core.n1.tone(98),
                        colorSurfaceVariant: core.n1.tone(90),
                        colorSurfaceHighlight: core.n1.tone(100),
                        surfaceHeader: core.n1.tone(90),
                        underSurface: core.n1.tone(0),
                        offState: core.n1.tone(20),
                        accentSurface: core.a2.tone(95),
                        textPrimaryOnAccent: core.n1.tone(10),
                        textSecondaryOnAccent: core.n2.tone(30),
                        volumeBackground: core.n1.tone(25),
                        scrim: core.n1.tone(80),
                    });
                }
                /**
                 * Dark scheme from core palette
                 */
                static darkFromCorePalette(core) {
                    return new SchemeAndroid({
                        colorAccentPrimary: core.a1.tone(90),
                        colorAccentPrimaryVariant: core.a1.tone(70),
                        colorAccentSecondary: core.a2.tone(90),
                        colorAccentSecondaryVariant: core.a2.tone(70),
                        colorAccentTertiary: core.a3.tone(90),
                        colorAccentTertiaryVariant: core.a3.tone(70),
                        textColorPrimary: core.n1.tone(95),
                        textColorSecondary: core.n2.tone(80),
                        textColorTertiary: core.n2.tone(60),
                        textColorPrimaryInverse: core.n1.tone(10),
                        textColorSecondaryInverse: core.n1.tone(30),
                        textColorTertiaryInverse: core.n1.tone(50),
                        colorBackground: core.n1.tone(10),
                        colorBackgroundFloating: core.n1.tone(10),
                        colorSurface: core.n1.tone(20),
                        colorSurfaceVariant: core.n1.tone(30),
                        colorSurfaceHighlight: core.n1.tone(35),
                        surfaceHeader: core.n1.tone(30),
                        underSurface: core.n1.tone(0),
                        offState: core.n1.tone(20),
                        accentSurface: core.a2.tone(95),
                        textPrimaryOnAccent: core.n1.tone(10),
                        textSecondaryOnAccent: core.n2.tone(30),
                        volumeBackground: core.n1.tone(25),
                        scrim: core.n1.tone(80),
                    });
                }
                toJSON() {
                    return Object.assign({}, this.props);
                }
            };
            exports_15("SchemeAndroid", SchemeAndroid);
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("score/score", ["hct/cam16", "utils/color_utils", "utils/math_utils"], function (exports_16, context_16) {
    "use strict";
    var cam16_4, utils, math, Score;
    var __moduleName = context_16 && context_16.id;
    return {
        setters: [
            function (cam16_4_1) {
                cam16_4 = cam16_4_1;
            },
            function (utils_6) {
                utils = utils_6;
            },
            function (math_3) {
                math = math_3;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             *  Given a large set of colors, remove colors that are unsuitable for a UI
             *  theme, and rank the rest based on suitability.
             *
             *  Enables use of a high cluster count for image quantization, thus ensuring
             *  colors aren't muddied, while curating the high cluster count to a much
             *  smaller number of appropriate choices.
             */
            Score = class Score {
                constructor() { }
                /**
                 * Given a map with keys of colors and values of how often the color appears,
                 * rank the colors based on suitability for being used for a UI theme.
                 *
                 * @param colorsToPopulation map with keys of colors and values of how often
                 *     the color appears, usually from a source image.
                 * @return Colors sorted by suitability for a UI theme. The most suitable
                 *     color is the first item, the least suitable is the last. There will
                 *     always be at least one color returned. If all the input colors
                 *     were not suitable for a theme, a default fallback color will be
                 *     provided, Google Blue.
                 */
                static score(colorsToPopulation, contentColor = false) {
                    // Determine the total count of all colors.
                    let populationSum = 0;
                    for (const population of colorsToPopulation.values()) {
                        populationSum += population;
                    }
                    // Turn the count of each color into a proportion by dividing by the total
                    // count. Also, fill a cache of CAM16 colors representing each color, and
                    // record the proportion of colors for each CAM16 hue.
                    const colorsToProportion = new Map();
                    const colorsToCam = new Map();
                    const hueProportions = new Array(360).fill(0);
                    for (const [color, population] of colorsToPopulation.entries()) {
                        const proportion = population / populationSum;
                        colorsToProportion.set(color, proportion);
                        const cam = cam16_4.Cam16.fromInt(color);
                        colorsToCam.set(color, cam);
                        const hue = Math.round(cam.hue);
                        hueProportions[hue] += proportion;
                    }
                    // Determine the proportion of the colors around each color, by summing the
                    // proportions around each color's hue.
                    const colorsToExcitedProportion = new Map();
                    for (const [color, cam] of colorsToCam.entries()) {
                        const hue = Math.round(cam.hue);
                        let excitedProportion = 0;
                        for (let i = (hue - 15); i < (hue + 15); i++) {
                            const neighborHue = math.sanitizeDegreesInt(i);
                            excitedProportion += hueProportions[neighborHue];
                        }
                        colorsToExcitedProportion.set(color, excitedProportion);
                    }
                    // Score the colors by their proportion, as well as how chromatic they are.
                    const colorsToScore = new Map();
                    for (const [color, cam] of colorsToCam.entries()) {
                        const proportion = colorsToExcitedProportion.get(color);
                        const proportionScore = proportion * 100.0 * Score.WEIGHT_PROPORTION;
                        const chromaWeight = cam.chroma < Score.TARGET_CHROMA ?
                            Score.WEIGHT_CHROMA_BELOW :
                            Score.WEIGHT_CHROMA_ABOVE;
                        const chromaScore = (cam.chroma - Score.TARGET_CHROMA) * chromaWeight;
                        const score = proportionScore + chromaScore;
                        colorsToScore.set(color, score);
                    }
                    // Remove colors that are unsuitable, ex. very dark or unchromatic colors.
                    // Also, remove colors that are very similar in hue.
                    const filteredColors = contentColor ?
                        Score.filterContent(colorsToCam) :
                        Score.filter(colorsToExcitedProportion, colorsToCam);
                    const dedupedColorsToScore = new Map();
                    for (const color of filteredColors) {
                        let duplicateHue = false;
                        const hue = colorsToCam.get(color).hue;
                        for (const [alreadyChosenColor,] of dedupedColorsToScore) {
                            const alreadyChosenHue = colorsToCam.get(alreadyChosenColor).hue;
                            if (math.differenceDegrees(hue, alreadyChosenHue) < 15) {
                                duplicateHue = true;
                                break;
                            }
                        }
                        if (duplicateHue) {
                            continue;
                        }
                        dedupedColorsToScore.set(color, colorsToScore.get(color));
                    }
                    // Ensure the list of colors returned is sorted such that the first in the
                    // list is the most suitable, and the last is the least suitable.
                    const colorsByScoreDescending = Array.from(dedupedColorsToScore.entries());
                    colorsByScoreDescending.sort((first, second) => {
                        return second[1] - first[1];
                    });
                    const answer = colorsByScoreDescending.map((entry) => {
                        return entry[0];
                    });
                    // Ensure that at least one color is returned.
                    if (answer.length === 0) {
                        answer.push(0xff4285F4); // Google Blue
                    }
                    return answer;
                }
                static filter(colorsToExcitedProportion, colorsToCam) {
                    const filtered = new Array();
                    for (const [color, cam] of colorsToCam.entries()) {
                        const proportion = colorsToExcitedProportion.get(color);
                        if (cam.chroma >= Score.CUTOFF_CHROMA &&
                            utils.lstarFromArgb(color) >= Score.CUTOFF_TONE &&
                            proportion >= Score.CUTOFF_EXCITED_PROPORTION) {
                            filtered.push(color);
                        }
                    }
                    return filtered;
                }
                static filterContent(colorsToCam) {
                    return Array.from(colorsToCam.keys());
                }
            };
            exports_16("Score", Score);
            Score.TARGET_CHROMA = 48.0;
            Score.WEIGHT_PROPORTION = 0.7;
            Score.WEIGHT_CHROMA_ABOVE = 0.3;
            Score.WEIGHT_CHROMA_BELOW = 0.1;
            Score.CUTOFF_CHROMA = 15.0;
            Score.CUTOFF_TONE = 10.0;
            Score.CUTOFF_EXCITED_PROPORTION = 0.01;
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("utils/string_utils", ["utils/color_utils"], function (exports_17, context_17) {
    "use strict";
    var colorUtils, hexFromArgb, argbFromHex;
    var __moduleName = context_17 && context_17.id;
    function parseIntHex(value) {
        // tslint:disable-next-line:ban
        return parseInt(value, 16);
    }
    return {
        setters: [
            function (colorUtils_3) {
                colorUtils = colorUtils_3;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * Utility methods for hexadecimal representations of colors.
             */
            /**
             * @param argb ARGB representation of a color.
             * @return Hex string representing color, ex. #ff0000 for red.
             */
            exports_17("hexFromArgb", hexFromArgb = (argb) => {
                const r = colorUtils.redFromArgb(argb);
                const g = colorUtils.greenFromArgb(argb);
                const b = colorUtils.blueFromArgb(argb);
                const outParts = [r.toString(16), g.toString(16), b.toString(16)];
                // Pad single-digit output values
                for (const [i, part] of outParts.entries()) {
                    if (part.length === 1) {
                        outParts[i] = '0' + part;
                    }
                }
                return '#' + outParts.join('');
            });
            /**
             * @param hex String representing color as hex code. Accepts strings with or
             *     without leading #, and string representing the color using 3, 6, or 8
             *     hex characters.
             * @return ARGB representation of color.
             */
            exports_17("argbFromHex", argbFromHex = (hex) => {
                hex = hex.replace('#', '');
                const isThree = hex.length === 3;
                const isSix = hex.length === 6;
                const isEight = hex.length === 8;
                if (!isThree && !isSix && !isEight) {
                    throw new Error('unexpected hex ' + hex);
                }
                let r = 0;
                let g = 0;
                let b = 0;
                if (isThree) {
                    r = parseIntHex(hex.slice(0, 1).repeat(2));
                    g = parseIntHex(hex.slice(1, 2).repeat(2));
                    b = parseIntHex(hex.slice(2, 3).repeat(2));
                }
                else if (isSix) {
                    r = parseIntHex(hex.slice(0, 2));
                    g = parseIntHex(hex.slice(2, 4));
                    b = parseIntHex(hex.slice(4, 6));
                }
                else if (isEight) {
                    r = parseIntHex(hex.slice(2, 4));
                    g = parseIntHex(hex.slice(4, 6));
                    b = parseIntHex(hex.slice(6, 8));
                }
                return (((255 << 24) | ((r & 0x0ff) << 16) | ((g & 0x0ff) << 8) | (b & 0x0ff)) >>>
                    0);
            });
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("utils/image_utils", ["quantize/quantizer_celebi", "score/score", "utils/color_utils"], function (exports_18, context_18) {
    "use strict";
    var quantizer_celebi_1, score_1, color_utils_1;
    var __moduleName = context_18 && context_18.id;
    /**
     * Get the source color from an image.
     *
     * @param image The image element
     * @return Source color - the color most suitable for creating a UI theme
     */
    function sourceColorFromImage(image) {
        return __awaiter(this, void 0, void 0, function* () {
            // Convert Image data to Pixel Array
            const imageBytes = yield new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                if (!context) {
                    return reject(new Error('Could not get canvas context'));
                }
                image.onload = () => {
                    canvas.width = image.width;
                    canvas.height = image.height;
                    context.drawImage(image, 0, 0);
                    resolve(context.getImageData(0, 0, image.width, image.height).data);
                };
            });
            // Convert Image data to Pixel Array
            const pixels = [];
            for (let i = 0; i < imageBytes.length; i += 4) {
                const r = imageBytes[i];
                const g = imageBytes[i + 1];
                const b = imageBytes[i + 2];
                const a = imageBytes[i + 3];
                if (a < 255) {
                    continue;
                }
                const argb = color_utils_1.argbFromRgb(r, g, b);
                pixels.push(argb);
            }
            // Convert Pixels to Material Colors
            const result = quantizer_celebi_1.QuantizerCelebi.quantize(pixels, 128);
            const ranked = score_1.Score.score(result);
            const top = ranked[0];
            return top;
        });
    }
    exports_18("sourceColorFromImage", sourceColorFromImage);
    return {
        setters: [
            function (quantizer_celebi_1_1) {
                quantizer_celebi_1 = quantizer_celebi_1_1;
            },
            function (score_1_1) {
                score_1 = score_1_1;
            },
            function (color_utils_1_1) {
                color_utils_1 = color_utils_1_1;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("utils/theme_utils", ["blend/blend", "palettes/core_palette", "scheme/scheme", "utils/image_utils", "utils/string_utils"], function (exports_19, context_19) {
    "use strict";
    var blend_1, core_palette_3, scheme_1, image_utils_1, string_utils_1;
    var __moduleName = context_19 && context_19.id;
    /**
     * Generate a theme from a source color
     *
     * @param source Source color
     * @param customColors Array of custom colors
     * @return Theme object
     */
    function themeFromSourceColor(source, customColors = []) {
        const palette = core_palette_3.CorePalette.of(source);
        return {
            source,
            schemes: {
                light: scheme_1.Scheme.light(source),
                dark: scheme_1.Scheme.dark(source),
            },
            palettes: {
                primary: palette.a1,
                secondary: palette.a2,
                tertiary: palette.a3,
                neutral: palette.n1,
                neutralVariant: palette.n2,
                error: palette.error,
            },
            customColors: customColors.map((c) => customColor(source, c)),
        };
    }
    exports_19("themeFromSourceColor", themeFromSourceColor);
    /**
     * Generate a theme from an image source
     *
     * @param image Image element
     * @param customColors Array of custom colors
     * @return Theme object
     */
    function themeFromImage(image, customColors = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const source = yield image_utils_1.sourceColorFromImage(image);
            return themeFromSourceColor(source, customColors);
        });
    }
    exports_19("themeFromImage", themeFromImage);
    /**
     * Generate custom color group from source and target color
     *
     * @param source Source color
     * @param color Custom color
     * @return Custom color group
     *
     * @link https://m3.material.io/styles/color/the-color-system/color-roles
     */
    function customColor(source, color) {
        let value = color.value;
        const from = value;
        const to = source;
        if (color.blend) {
            value = blend_1.Blend.harmonize(from, to);
        }
        const palette = core_palette_3.CorePalette.of(value);
        const tones = palette.a1;
        return {
            color,
            value,
            light: {
                color: tones.tone(40),
                onColor: tones.tone(100),
                colorContainer: tones.tone(90),
                onColorContainer: tones.tone(10),
            },
            dark: {
                color: tones.tone(80),
                onColor: tones.tone(20),
                colorContainer: tones.tone(30),
                onColorContainer: tones.tone(90),
            },
        };
    }
    exports_19("customColor", customColor);
    /**
     * Apply a theme to an element
     *
     * @param theme Theme object
     * @param options Options
     */
    function applyTheme(theme, options) {
        var _a, _b;
        const target = (options === null || options === void 0 ? void 0 : options.target) || document.body;
        const isDark = (_a = options === null || options === void 0 ? void 0 : options.dark) !== null && _a !== void 0 ? _a : false;
        const scheme = isDark ? theme.schemes.dark : theme.schemes.light;
        setSchemeProperties(target, scheme);
        if (options === null || options === void 0 ? void 0 : options.brightnessSuffix) {
            setSchemeProperties(target, theme.schemes.dark, '-dark');
            setSchemeProperties(target, theme.schemes.light, '-light');
        }
        if (options === null || options === void 0 ? void 0 : options.paletteTones) {
            const tones = (_b = options === null || options === void 0 ? void 0 : options.paletteTones) !== null && _b !== void 0 ? _b : [];
            for (const [key, palette] of Object.entries(theme.palettes)) {
                const paletteKey = key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
                for (const tone of tones) {
                    const token = `--md-ref-palette-${paletteKey}-${paletteKey}${tone}`;
                    const color = string_utils_1.hexFromArgb(palette.tone(tone));
                    target.style.setProperty(token, color);
                }
            }
        }
    }
    exports_19("applyTheme", applyTheme);
    function setSchemeProperties(target, scheme, suffix = '') {
        for (const [key, value] of Object.entries(scheme.toJSON())) {
            const token = key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
            const color = string_utils_1.hexFromArgb(value);
            target.style.setProperty(`--md-sys-color-${token}${suffix}`, color);
        }
    }
    return {
        setters: [
            function (blend_1_1) {
                blend_1 = blend_1_1;
            },
            function (core_palette_3_1) {
                core_palette_3 = core_palette_3_1;
            },
            function (scheme_1_1) {
                scheme_1 = scheme_1_1;
            },
            function (image_utils_1_1) {
                image_utils_1 = image_utils_1_1;
            },
            function (string_utils_1_1) {
                string_utils_1 = string_utils_1_1;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("index", ["blend/blend", "hct/cam16", "hct/hct", "hct/viewing_conditions", "palettes/core_palette", "palettes/tonal_palette", "quantize/quantizer_celebi", "quantize/quantizer_map", "quantize/quantizer_wsmeans", "quantize/quantizer_wu", "scheme/scheme", "scheme/scheme_android", "score/score", "utils/color_utils", "utils/math_utils", "utils/string_utils", "utils/image_utils", "utils/theme_utils"], function (exports_20, context_20) {
    "use strict";
    var __moduleName = context_20 && context_20.id;
    function exportStar_1(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_20(exports);
    }
    return {
        setters: [
            function (blend_2_1) {
                exportStar_1(blend_2_1);
            },
            function (cam16_5_1) {
                exportStar_1(cam16_5_1);
            },
            function (hct_4_1) {
                exportStar_1(hct_4_1);
            },
            function (viewing_conditions_3_1) {
                exportStar_1(viewing_conditions_3_1);
            },
            function (core_palette_4_1) {
                exportStar_1(core_palette_4_1);
            },
            function (tonal_palette_2_1) {
                exportStar_1(tonal_palette_2_1);
            },
            function (quantizer_celebi_2_1) {
                exportStar_1(quantizer_celebi_2_1);
            },
            function (quantizer_map_2_1) {
                exportStar_1(quantizer_map_2_1);
            },
            function (quantizer_wsmeans_2_1) {
                exportStar_1(quantizer_wsmeans_2_1);
            },
            function (quantizer_wu_2_1) {
                exportStar_1(quantizer_wu_2_1);
            },
            function (scheme_2_1) {
                exportStar_1(scheme_2_1);
            },
            function (scheme_android_1_1) {
                exportStar_1(scheme_android_1_1);
            },
            function (score_2_1) {
                exportStar_1(score_2_1);
            },
            function (color_utils_2_1) {
                exportStar_1(color_utils_2_1);
            },
            function (math_utils_1_1) {
                exportStar_1(math_utils_1_1);
            },
            function (string_utils_2_1) {
                exportStar_1(string_utils_2_1);
            },
            function (image_utils_2_1) {
                exportStar_1(image_utils_2_1);
            },
            function (theme_utils_1_1) {
                exportStar_1(theme_utils_1_1);
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            // console.log('hello')
            throw new Error;
        }
    };
});
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
System.register("quantize/lab_point_provider", ["./point_provider", "utils/color_utils"], function (exports_21, context_21) {
    "use strict";
    var utils, LabPointProvider;
    var __moduleName = context_21 && context_21.id;
    return {
        setters: [
            function (_1) {
            },
            function (utils_7) {
                utils = utils_7;
            }
        ],
        execute: function () {/**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * Provides conversions needed for K-Means quantization. Converting input to
             * points, and converting the final state of the K-Means algorithm to colors.
             */
            LabPointProvider = class LabPointProvider {
                /**
                 * Convert a color represented in ARGB to a 3-element array of L*a*b*
                 * coordinates of the color.
                 */
                fromInt(argb) {
                    return utils.labFromArgb(argb);
                }
                /**
                 * Convert a 3-element array to a color represented in ARGB.
                 */
                toInt(point) {
                    return utils.argbFromLab(point[0], point[1], point[2]);
                }
                /**
                 * Standard CIE 1976 delta E formula also takes the square root, unneeded
                 * here. This method is used by quantization algorithms to compare distance,
                 * and the relative ordering is the same, with or without a square root.
                 *
                 * This relatively minor optimization is helpful because this method is
                 * called at least once for each pixel in an image.
                 */
                distance(from, to) {
                    const dL = from[0] - to[0];
                    const dA = from[1] - to[1];
                    const dB = from[2] - to[2];
                    return dL * dL + dA * dA + dB * dB;
                }
            };
            exports_21("LabPointProvider", LabPointProvider);
        }
    };
});
